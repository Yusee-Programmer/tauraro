//! Tests for the bytecode implementation

#[cfg(test)]
mod tests {
    use tauraro::{SuperCompiler, SuperBytecodeVM, OpCode, Lexer, Parser};

    #[test]
    fn test_simple_arithmetic() {
        let source = "result = 2 + 3";
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        // Check that we have the expected instructions
        assert_eq!(code.instructions.len(), 10); // LoadConst(2), LoadConst(3), BinaryAdd, etc.
        
        // Check specific instructions
        assert_eq!(code.instructions[0].opcode, OpCode::LoadConst);
        assert_eq!(code.instructions[1].opcode, OpCode::LoadConst);
        assert_eq!(code.instructions[2].opcode, OpCode::BinaryAddRR); // Updated to use our new opcode
    }

    #[test]
    fn test_list_creation() {
        let source = "my_list = [1, 2, 3]";
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        // Check that we have BuildList instruction
        let has_build_list = code.instructions.iter().any(|instr| instr.opcode == OpCode::BuildList);
        assert!(has_build_list);
    }

    #[test]
    fn test_function_call() {
        let source = "print('Hello')";
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        // Check that we have CallFunction instruction
        let has_call = code.instructions.iter().any(|instr| instr.opcode == OpCode::CallFunction);
        assert!(has_call);
    }

    #[test]
    fn test_vm_execution() {
        let source = "result = 2 + 3";
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        let mut vm = SuperBytecodeVM::new(); // Updated to use our new VM
        let result = vm.execute(code);
        assert!(result.is_ok());
    }

    // New tests for our implemented opcodes
    #[test]
    fn test_pop_jump_if_false_opcode() {
        // This test would require creating a code object with PopJumpIfFalse directly
        // Since PopJumpIfFalse is typically generated by the compiler for control flow,
        // we'll just check that the opcode exists
        let opcode = OpCode::PopJumpIfFalse;
        assert_eq!(format!("{:?}", opcode), "PopJumpIfFalse");
    }

    #[test]
    fn test_make_function_opcode() {
        // This test would require creating a code object with MakeFunction directly
        // Since MakeFunction is typically generated by the compiler for function definitions,
        // we'll just check that the opcode exists
        let opcode = OpCode::MakeFunction;
        assert_eq!(format!("{:?}", opcode), "MakeFunction");
    }

    #[test]
    fn test_build_list_opcode() {
        // This test would require creating a code object with BuildList directly
        // Since BuildList is typically generated by the compiler for list literals,
        // we'll just check that the opcode exists
        let opcode = OpCode::BuildList;
        assert_eq!(format!("{:?}", opcode), "BuildList");
    }
}

#[cfg(all(test, feature = "jit"))]
mod jit_tests {
    use tauraro::{SuperCompiler, SuperBytecodeVM, OpCode, Lexer, Parser}; // Updated to use our new implementation

    #[test]
    fn test_jit_compilation_trigger() {
        let source = r#"
def hot_function(x):
    return x + 1

# Call the function multiple times to trigger JIT compilation
result = 0
for i in range(1000):
    result = hot_function(i)
"#;
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        let mut vm = SuperBytecodeVM::new(); // Updated to use our new VM
        let result = vm.execute(code);
        assert!(result.is_ok());
        
        // Verify that the function was JIT compiled
        assert!(vm.jit_compiled_functions.contains_key("hot_function"));
    }

    #[test]
    fn test_jit_fallback() {
        let source = r#"
def complex_function(x):
    # Add complex operations that might cause JIT compilation to fail
    try:
        result = x + 1
        if x > 100:
            raise ValueError("Too large")
        return result
    except:
        return 0

# Call the function multiple times
result = 0
for i in range(1000):
    result = complex_function(i)
"#;
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        let mut vm = SuperBytecodeVM::new(); // Updated to use our new VM
        let result = vm.execute(code);
        assert!(result.is_ok());
        
        // Even if JIT compilation fails, the interpreter fallback should work
        assert!(result.is_ok());
    }

    #[test]
    fn test_jit_performance() {
        let source = r#"
def compute_sum(n):
    total = 0
    for i in range(n):
        total += i
    return total

# Call the function multiple times with different inputs
results = []
for i in range(100):
    results.append(compute_sum(1000))
"#;
        let tokens = Lexer::new(source).collect::<Result<Vec<_>, _>>().unwrap();
        let mut parser = Parser::new(tokens);
        let program = parser.parse().unwrap();
        
        let mut compiler = SuperCompiler::new("test".to_string()); // Updated to use our new compiler
        let code = compiler.compile(program).unwrap();
        
        let mut vm = SuperBytecodeVM::new(); // Updated to use our new VM
        
        use std::time::Instant;
        let start = Instant::now();
        let result = vm.execute(code);
        let duration = start.elapsed();
        
        assert!(result.is_ok());
        assert!(vm.jit_compiled_functions.contains_key("compute_sum"));
        
        // Log performance metrics
        log::info!("JIT execution time: {:?}", duration);
    }
}