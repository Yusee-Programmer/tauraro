# Tauraro FFI Modules Guide

## Overview

This guide explains how to use and compile the builtin FFI modules in Tauraro. All FFI modules are designed to be compiled to object files and linked with C code generated by the Tauraro transpiler.

## Available FFI Modules

All 29 builtin modules have been implemented with C-compatible FFI exports:

### Core Modules
- **math**: Mathematical functions (sqrt, sin, cos, pow, log, etc.)
- **sys**: System-specific parameters and functions
- **os**: Operating system interface (file operations, environment variables)
- **time**: Time access and conversions
- **random**: Random number generation

### Data Processing
- **json**: JSON encoder and decoder
- **csv**: CSV file reading and writing
- **pickle**: Python object serialization
- **base64**: Base64 encoding and decoding

### Collections & Utilities
- **collections**: Specialized container datatypes
- **itertools**: Iterator building blocks
- **functools**: Higher-order functions and operations on callable objects
- **copy**: Shallow and deep copy operations

### Text Processing
- **re**: Regular expression operations
- **logging**: Flexible event logging system
- **io**: Core tools for working with streams

### Security & Hashing
- **hashlib**: Secure hash and message digest algorithms

### Network & Web
- **socket**: Low-level networking interface
- **urllib**: URL handling modules
- **httptools**: HTTP parsing
- **httpx**: HTTP client library
- **websockets**: WebSocket client and server library
- **asyncio**: Asynchronous I/O

### Testing & Development
- **unittest**: Unit testing framework
- **abc**: Abstract Base Classes

### System & Runtime
- **threading**: Thread-based parallelism
- **memory**: Memory management utilities
- **gc**: Garbage collector interface
- **exceptions**: Standard exception hierarchy
- **datetime**: Basic date and time types

## Compilation Process

### Prerequisites

- Rust compiler (rustc) version 1.89.0 or later
- C compiler (GCC, Clang, or MSVC)
- Python 3.7+ (for build scripts)

### Compiling FFI Modules

#### Method 1: Compile All Modules (Recommended)

```bash
cd /path/to/tauraro
python compile_all_ffi.py
```

This script will:
- Compile all 29 FFI modules to object files
- Place them in `build/builtin/*.o`
- Report success/failure for each module

#### Method 2: Compile Individual Modules

```bash
rustc --crate-type staticlib --emit obj -C panic=abort -O \
    src/builtins_ffi/math_ffi.rs \
    -o build/builtin/math_ffi.o
```

Replace `math` with any module name.

### Compilation Flags Explained

- `--crate-type staticlib`: Generate a static library
- `--emit obj`: Emit object file instead of full library
- `-C panic=abort`: Use abort on panic (required for `#![no_std]`)
- `-O`: Enable optimizations

## Using FFI Modules with C Transpilation

### Step 1: Write Tauraro Code

```python
# example.tr
import math
import sys

print("Square root of 16 is:", math.sqrt(16))
print("Running on platform:", sys.platform)
```

### Step 2: Transpile to C

```bash
./target/release/tauraro.exe compile example.tr
```

This generates C code in `build/example.c` that includes extern declarations for FFI functions.

### Step 3: Compile with FFI Linking

The Tauraro compiler automatically:
1. Detects which builtin modules are used
2. Compiles the corresponding Rust FFI modules to object files
3. Links them with the generated C code

```bash
# This is done automatically by the compiler
gcc build/example.c build/builtin/math_ffi.o build/builtin/sys_ffi.o \
    -o example.exe -lm
```

## FFI Module Architecture

### Module Structure

Each FFI module follows this pattern:

```rust
//! Module documentation

#![no_std]  // No standard library - for minimal dependencies

use core::ffi::c_int;
use core::panic::PanicInfo;

// Panic handler required for no_std
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}

// Type definitions matching C ABI
#[repr(C)]
#[derive(PartialEq, Eq)]
pub enum TauraroType { ... }

#[repr(C)]
pub union TauraroData { ... }

#[repr(C)]
pub struct TauraroValue { ... }

// Helper functions
unsafe fn create_value(...) -> *mut TauraroValue { ... }

// Exported FFI functions
#[no_mangle]
pub extern "C" fn tauraro_<module>_<function>(
    argc: c_int,
    argv: *mut *mut TauraroValue
) -> *mut TauraroValue {
    // Implementation
}
```

### Function Naming Convention

All FFI functions follow this pattern:
```
tauraro_<module>_<function>
```

Examples:
- `tauraro_math_sqrt`
- `tauraro_json_dumps`
- `tauraro_os_getcwd`

### Constants and Static Variables

For modules with constants (e.g., `math.pi`, `sys.platform`):

```rust
#[no_mangle]
pub static tauraro_math_pi: f64 = 3.141592653589793;
```

For static string pointers, we use a `ConstPtr` wrapper to ensure thread safety:

```rust
struct ConstPtr(*const u8);
unsafe impl Sync for ConstPtr {}

#[no_mangle]
pub static tauraro_sys_platform: ConstPtr = ConstPtr::new(
    b"win32\0".as_ptr()
);
```

## C ABI Compatibility

### Value Types

The `TauraroValue` struct represents all Python/Tauraro values:

```c
typedef enum {
    TAURARO_INT = 0,
    TAURARO_FLOAT = 1,
    TAURARO_BOOL = 2,
    TAURARO_STRING = 3,
    // ... other types
} TauraroType;

typedef union {
    int64_t int_val;
    double float_val;
    bool bool_val;
    char* str_val;
} TauraroData;

typedef struct {
    TauraroType value_type;
    int ref_count;
    TauraroData data;
} TauraroValue;
```

### Function Signatures

All FFI functions have the signature:

```c
TauraroValue* function_name(int argc, TauraroValue** argv);
```

- `argc`: Number of arguments
- `argv`: Array of argument pointers
- Returns: Pointer to result value (or NULL on error)

## Testing

### Test Python Script

```bash
python test_ffi_modules.py
```

This tests basic functionality of common modules using standard Python.

### Test with Tauraro

```bash
# Create a test script
cat > test_modules.tr << 'EOF'
import math
import sys
import json

print("Math test:", math.sqrt(25))
print("Sys test:", sys.platform)
print("JSON test:", json.dumps({"test": 123}))
EOF

# Compile and run
./target/release/tauraro.exe run test_modules.tr
```

## Troubleshooting

### Compilation Errors

**Error: `TauraroType` doesn't implement `PartialEq`**
- Solution: Add `#[derive(PartialEq, Eq)]` to `TauraroType` enum

**Error: `*const u8` cannot be shared between threads**
- Solution: Wrap static pointers in `ConstPtr` with `unsafe impl Sync`

**Error: Unclosed delimiter**
- Solution: Check that all braces and parentheses are balanced in static initializers

### Linking Errors

**Undefined reference to `tauraro_value_new`**
- Solution: Ensure the main C program defines this function

**Multiple definition errors**
- Solution: Each FFI module should be compiled separately to its own object file

## Performance Considerations

### Optimization Levels

- Use `-O` flag for general optimization
- For release builds, consider `-O3`
- Profile before optimizing further

### No-std Benefits

Using `#![no_std]`:
- Smaller binary size
- Faster compilation
- No runtime dependencies
- Better for embedded targets

### FFI Overhead

- FFI calls have minimal overhead
- Value conversions are lightweight
- No heap allocations in hot paths

## Future Enhancements

Potential improvements:

1. **Error Handling**: Return error codes instead of NULL
2. **Memory Management**: Implement proper reference counting
3. **Type Safety**: Add runtime type checking
4. **Async Support**: Implement async FFI functions
5. **Platform-Specific Optimizations**: Use SIMD where applicable

## Contributing

When adding new FFI modules:

1. Follow the existing module structure
2. Use `#![no_std]` for portability
3. Add proper error handling
4. Document all exported functions
5. Add tests in `test_ffi_modules.py`
6. Update this guide

## License

All FFI modules are part of the Tauraro project and share the same license.
