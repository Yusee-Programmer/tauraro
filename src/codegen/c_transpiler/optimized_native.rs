//! Optimized Native C Code Generation for Tauraro
//!
//! This module provides high-performance C code generation using native types

use std::collections::HashMap;
use crate::ast::*;
use crate::codegen::c_transpiler::native_types::{NativeType, NativeTypeContext};
use crate::codegen::c_transpiler::optimizer::NativeOptimizer;
use crate::codegen::c_transpiler::memory_management::{MemoryCodeGenerator, MemoryStrategy};

pub struct OptimizedNativeTranspiler {
    /// Type context for tracking variable types
    context: NativeTypeContext,
    /// Current indentation level
    indent_level: usize,
    /// Counter for temporary variables
    temp_counter: usize,
    /// Optimizer for code generation
    optimizer: NativeOptimizer,
    /// Enable optimizations
    optimizations_enabled: bool,
    /// Memory management code generator
    memory_manager: MemoryCodeGenerator,
}

impl OptimizedNativeTranspiler {
    pub fn new() -> Self {
        Self {
            context: NativeTypeContext::new(),
            indent_level: 0,
            temp_counter: 0,
            optimizer: NativeOptimizer::new(),
            optimizations_enabled: true,
            memory_manager: MemoryCodeGenerator::new(MemoryStrategy::default()),
        }
    }

    pub fn with_optimizations(mut self, enabled: bool) -> Self {
        self.optimizations_enabled = enabled;
        self
    }

    pub fn with_memory_strategy(mut self, strategy: MemoryStrategy) -> Self {
        self.memory_manager = MemoryCodeGenerator::new(strategy);
        self
    }

    /// Generate optimized C code from AST program
    pub fn transpile_program(&mut self, program: &Program) -> Result<String, String> {
        // Apply optimizations if enabled
        let mut optimized_program = program.clone();
        if self.optimizations_enabled {
            self.optimizer.optimize_program(&mut optimized_program);
        }

        let program = &optimized_program;
        let mut code = String::new();

        // Generate headers
        code.push_str(self.generate_headers().as_str());

        // Generate native type system
        code.push_str(&crate::codegen::c_transpiler::native_types::generate_native_type_declarations());
        code.push_str("\n");

        // Generate forward declarations
        code.push_str("// Forward declarations\n");
        for stmt in &program.statements {
            if let Statement::FunctionDef { name, .. } = stmt {
                code.push_str(&format!("// Function: {}\n", name));
            }
            if let Statement::ClassDef { name, .. } = stmt {
                code.push_str(&format!("typedef struct {} {}_t;\n", name, name));
            }
        }
        code.push_str("\n");

        // Generate classes
        for stmt in &program.statements {
            if let Statement::ClassDef { .. } = stmt {
                code.push_str(&self.transpile_class(stmt)?);
                code.push_str("\n");
            }
        }

        // Generate functions
        for stmt in &program.statements {
            if let Statement::FunctionDef { .. } = stmt {
                code.push_str(&self.transpile_function(stmt)?);
                code.push_str("\n");
            }
        }

        // Generate main function
        code.push_str(&self.generate_main_function(program)?);

        Ok(code)
    }

    fn generate_headers(&self) -> String {
        let mut headers = String::new();
        headers.push_str("// Generated by Tauraro Optimized Native C Transpiler\n");
        headers.push_str("#include <stdio.h>\n");
        headers.push_str("#include <stdlib.h>\n");
        headers.push_str("#include <stdint.h>\n");
        headers.push_str("#include <stdbool.h>\n");
        headers.push_str("#include <string.h>\n");
        headers.push_str("#include <math.h>\n");
        headers.push_str("#include <setjmp.h>\n");
        headers.push_str("\n");

        // Add memory management runtime
        headers.push_str(&self.memory_manager.generate_runtime_header());
        headers.push_str("\n");

        // Add built-in function implementations
        headers.push_str(&crate::codegen::c_transpiler::native_builtins::NativeBuiltins::generate_all_implementations());
        headers.push_str("\n");

        headers
    }

    fn transpile_class(&mut self, stmt: &Statement) -> Result<String, String> {
        if let Statement::ClassDef { name, bases, body, .. } = stmt {
            let mut code = String::new();

            code.push_str(&format!("// Class: {}\n", name));
            code.push_str(&format!("struct {}_t {{\n", name));

            // Add base class field if inheritance
            if !bases.is_empty() {
                if let Expr::Identifier(base_name) = &bases[0] {
                    code.push_str(&format!("    struct {}_t base;\n", base_name));
                }
            }

            // Add reference counting
            code.push_str("    int ref_count;\n");

            // Extract fields from body (simplified)
            code.push_str("    // Fields would be extracted from body\n");

            code.push_str("};\n\n");

            // Constructor and destructor would be generated here

            Ok(code)
        } else {
            Err("Expected ClassDef statement".to_string())
        }
    }

    fn transpile_function(&mut self, stmt: &Statement) -> Result<String, String> {
        if let Statement::FunctionDef { name, params, return_type, body, decorators, .. } = stmt {
            let mut code = String::new();

            // Check for memory management decorators
            let mut func_memory_strategy = None;
            for decorator in decorators {
                if let Expr::Identifier(dec_name) = decorator {
                    if dec_name == "manual_memory" {
                        func_memory_strategy = Some(MemoryStrategy::Manual);
                    } else if dec_name == "arena_memory" {
                        func_memory_strategy = Some(MemoryStrategy::Arena);
                    } else if dec_name == "auto_memory" {
                        func_memory_strategy = Some(MemoryStrategy::Automatic);
                    }
                }
            }

            // Save current strategy and switch if decorator present
            let prev_strategy = if let Some(strategy) = func_memory_strategy {
                let prev = self.memory_manager.context().strategy;
                self.memory_manager = MemoryCodeGenerator::new(strategy);
                Some(prev)
            } else {
                None
            };

            // Determine return type
            let ret_type = return_type.as_ref()
                .map(|t| self.map_type_to_native(t))
                .unwrap_or(NativeType::Void);

            // Function signature
            code.push_str(&ret_type.to_c_type());
            code.push(' ');
            code.push_str(name);
            code.push('(');

            if params.is_empty() {
                code.push_str("void");
            } else {
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        code.push_str(", ");
                    }

                    let param_type = param.type_annotation.as_ref()
                        .map(|t| self.map_type_to_native(t))
                        .unwrap_or(NativeType::Dynamic);

                    code.push_str(&param_type.to_c_type());
                    code.push(' ');
                    code.push_str(&param.name);

                    // Register parameter type
                    self.context.set_variable_type(param.name.clone(), param_type);
                }
            }

            code.push_str(") {\n");

            // Function body
            self.indent_level += 1;
            for body_stmt in body {
                code.push_str(&self.transpile_statement(body_stmt)?);
            }
            self.indent_level -= 1;

            code.push_str("}\n");

            // Restore previous memory strategy
            if let Some(prev) = prev_strategy {
                self.memory_manager = MemoryCodeGenerator::new(prev);
            }

            Ok(code)
        } else {
            Err("Expected FunctionDef statement".to_string())
        }
    }

    fn generate_main_function(&mut self, program: &Program) -> Result<String, String> {
        let mut code = String::new();

        code.push_str("int main(int argc, char** argv) {\n");
        self.indent_level += 1;

        // Transpile top-level statements
        for stmt in &program.statements {
            // Skip function and class definitions
            match stmt {
                Statement::FunctionDef { .. } | Statement::ClassDef { .. } => continue,
                _ => {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
            }
        }

        code.push_str(&self.indent());
        code.push_str("return 0;\n");

        self.indent_level -= 1;
        code.push_str("}\n");

        Ok(code)
    }

    fn transpile_statement(&mut self, stmt: &Statement) -> Result<String, String> {
        let mut code = self.indent();

        match stmt {
            Statement::Expression(expr) => {
                code.push_str(&self.transpile_expr(expr)?);
                code.push_str(";\n");
            }
            Statement::Return(value) => {
                code.push_str("return");
                if let Some(val) = value {
                    code.push(' ');
                    code.push_str(&self.transpile_expr(val)?);
                }
                code.push_str(";\n");
            }
            Statement::If { condition, then_branch, elif_branches, else_branch } => {
                code.push_str(&format!("if ({}) {{\n", self.transpile_expr(condition)?));
                self.indent_level += 1;
                for stmt in then_branch {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
                self.indent_level -= 1;

                // Handle elif branches
                for (elif_cond, elif_body) in elif_branches {
                    code.push_str(&self.indent());
                    code.push_str(&format!("}} else if ({}) {{\n", self.transpile_expr(elif_cond)?));
                    self.indent_level += 1;
                    for stmt in elif_body {
                        code.push_str(&self.transpile_statement(stmt)?);
                    }
                    self.indent_level -= 1;
                }

                if let Some(else_stmts) = else_branch {
                    code.push_str(&self.indent());
                    code.push_str("} else {\n");
                    self.indent_level += 1;
                    for stmt in else_stmts {
                        code.push_str(&self.transpile_statement(stmt)?);
                    }
                    self.indent_level -= 1;
                }

                code.push_str(&self.indent());
                code.push_str("}\n");
            }
            Statement::While { condition, body, else_branch } => {
                code.push_str(&format!("while ({}) {{\n", self.transpile_expr(condition)?));
                self.indent_level += 1;
                for stmt in body {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
                self.indent_level -= 1;
                code.push_str(&self.indent());
                code.push_str("}\n");

                // Note: else_branch on while is Python-specific, would need special handling
                if else_branch.is_some() {
                    code.push_str(&self.indent());
                    code.push_str("/* while-else not yet implemented */\n");
                }
            }
            Statement::For { variable, variables, iterable, body, else_branch } => {
                // Use primary variable or first of variables
                let loop_var = if !variable.is_empty() {
                    variable.clone()
                } else if !variables.is_empty() {
                    variables[0].clone()
                } else {
                    return Err("For loop has no target variable".to_string());
                };

                // Handle range() specially for performance
                if let Expr::Call { func, args, .. } = iterable {
                    if let Expr::Identifier(name) = func.as_ref() {
                        if name == "range" {
                            return self.transpile_range_for(&loop_var, args, body);
                        }
                    }
                }

                code.push_str("/* generic for loop not yet implemented */\n");

                if else_branch.is_some() {
                    code.push_str(&self.indent());
                    code.push_str("/* for-else not yet implemented */\n");
                }
            }
            Statement::VariableDef { name, type_annotation, value } => {
                let var_type = if let Some(typ) = type_annotation {
                    self.map_type_to_native(typ)
                } else if let Some(val) = value {
                    self.infer_expr_type(val)?
                } else {
                    NativeType::Dynamic
                };

                self.context.set_variable_type(name.clone(), var_type.clone());
                code.push_str(&var_type.to_c_type());
                code.push(' ');
                code.push_str(name);

                if let Some(val) = value {
                    code.push_str(" = ");
                    code.push_str(&self.transpile_expr(val)?);
                }
                code.push_str(";\n");
            }
            Statement::AttributeAssignment { object, name, value } => {
                code.push_str(&self.transpile_expr(object)?);
                code.push_str(".");
                code.push_str(name);
                code.push_str(" = ");
                code.push_str(&self.transpile_expr(value)?);
                code.push_str(";\n");
            }
            Statement::SubscriptAssignment { object, index, value } => {
                code.push_str(&self.transpile_expr(object)?);
                code.push('[');
                code.push_str(&self.transpile_expr(index)?);
                code.push_str("] = ");
                code.push_str(&self.transpile_expr(value)?);
                code.push_str(";\n");
            }
            Statement::Break => {
                code.push_str("break;\n");
            }
            Statement::Continue => {
                code.push_str("continue;\n");
            }
            Statement::Pass => {
                code.push_str("/* pass */;\n");
            }
            Statement::Try { body, except_handlers, else_branch, finally } => {
                self.transpile_try_statement(body, except_handlers, else_branch, finally, &mut code)?;
            }
            Statement::Raise(exception) => {
                self.transpile_raise_statement(exception, &mut code)?;
            }
            _ => {
                code.push_str("/* unsupported statement */;\n");
            }
        }

        Ok(code)
    }

    fn transpile_expr(&mut self, expr: &Expr) -> Result<String, String> {
        match expr {
            Expr::Literal(lit) => self.transpile_literal(lit),
            Expr::Identifier(name) => Ok(name.clone()),
            Expr::BinaryOp { left, op, right } => {
                let left_code = self.transpile_expr(left)?;
                let right_code = self.transpile_expr(right)?;
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "pow", // Would need function call
                    _ => "?",
                };
                Ok(format!("({} {} {})", left_code, op_str, right_code))
            }
            Expr::UnaryOp { op, operand } => {
                let operand_code = self.transpile_expr(operand)?;
                let op_str = match op {
                    UnaryOp::Not => "!",
                    UnaryOp::USub => "-",
                    UnaryOp::UAdd => "+",
                    _ => "?",
                };
                Ok(format!("({}{})", op_str, operand_code))
            }
            Expr::Call { func, args, .. } => {
                self.transpile_function_call(func, args)
            }
            Expr::List(items) => {
                let mut code = String::from("{");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        code.push_str(", ");
                    }
                    code.push_str(&self.transpile_expr(item)?);
                }
                code.push('}');
                Ok(code)
            }
            Expr::Subscript { object, index } => {
                Ok(format!("{}[{}]",
                    self.transpile_expr(object)?,
                    self.transpile_expr(index)?))
            }
            Expr::Attribute { object, name } => {
                Ok(format!("{}.{}", self.transpile_expr(object)?, name))
            }
            Expr::Compare { left, ops, comparators } => {
                // Simplified comparison
                if !ops.is_empty() && !comparators.is_empty() {
                    let left_code = self.transpile_expr(left)?;
                    let right_code = self.transpile_expr(&comparators[0])?;
                    let op_str = match &ops[0] {
                        CompareOp::Eq => "==",
                        CompareOp::NotEq => "!=",
                        CompareOp::Lt => "<",
                        CompareOp::LtE => "<=",
                        CompareOp::Gt => ">",
                        CompareOp::GtE => ">=",
                        _ => "==",
                    };
                    Ok(format!("({} {} {})", left_code, op_str, right_code))
                } else {
                    Ok("false".to_string())
                }
            }
            Expr::ListComp { element, generators } => {
                self.transpile_list_comprehension(element, generators)
            }
            Expr::DictComp { key, value, generators } => {
                self.transpile_dict_comprehension(key, value, generators)
            }
            Expr::SetComp { element, generators } => {
                self.transpile_set_comprehension(element, generators)
            }
            Expr::GeneratorExp { element, generators } => {
                // Generator expressions are more complex - for now convert to list
                self.transpile_list_comprehension(element, generators)
            }
            Expr::FormatString { parts } => {
                self.transpile_format_string(parts)
            }
            _ => Ok("/* unsupported expr */".to_string()),
        }
    }

    fn transpile_literal(&self, lit: &Literal) -> Result<String, String> {
        Ok(match lit {
            Literal::Int(n) => n.to_string(),
            Literal::Float(f) => f.to_string(),
            Literal::String(s) => {
                // Properly escape string literals for C
                let escaped = s
                    .replace("\\", "\\\\")  // Backslash first
                    .replace("\"", "\\\"")  // Quote
                    .replace("\n", "\\n")   // Newline
                    .replace("\r", "\\r")   // Carriage return
                    .replace("\t", "\\t")   // Tab
                    .replace("\0", "\\0");  // Null
                format!("\"{}\"", escaped)
            }
            Literal::Bool(b) => if *b { "true" } else { "false" }.to_string(),
            Literal::None => "NULL".to_string(),
            _ => "NULL".to_string(),
        })
    }

    fn transpile_format_string(&mut self, parts: &[FormatPart]) -> Result<String, String> {
        // Convert f-string to sprintf or direct concatenation
        // For now, generate a sprintf call
        let mut format_str = String::new();
        let mut args = Vec::new();

        for part in parts {
            match part {
                FormatPart::String(s) => {
                    // Escape the string part
                    let escaped = s
                        .replace("\\", "\\\\")
                        .replace("\"", "\\\"")
                        .replace("\n", "\\n")
                        .replace("\r", "\\r")
                        .replace("\t", "\\t");
                    format_str.push_str(&escaped);
                }
                FormatPart::Expression { expr, format_spec, .. } => {
                    // Infer type and add appropriate format specifier
                    let expr_type = self.infer_expr_type(expr)?;
                    let expr_code = self.transpile_expr(expr)?;

                    // Handle format spec if present
                    let fmt = if let Some(spec) = format_spec {
                        // Parse format spec (e.g., ".4f" for floats)
                        if spec.contains('f') || spec.contains('e') || spec.contains('g') {
                            format!("%{}", spec)
                        } else if spec.contains('d') {
                            format!("%{}", spec)
                        } else {
                            // Default based on type
                            match expr_type {
                                NativeType::Int => "%lld".to_string(),
                                NativeType::Float => {
                                    if spec.is_empty() {
                                        "%g".to_string()
                                    } else {
                                        format!("%{}", spec)
                                    }
                                }
                                NativeType::String => "%s".to_string(),
                                NativeType::Bool => "%s".to_string(),
                                _ => "%p".to_string(),
                            }
                        }
                    } else {
                        // Default format based on type
                        match expr_type {
                            NativeType::Int => "%lld".to_string(),
                            NativeType::Float => "%g".to_string(),
                            NativeType::String => "%s".to_string(),
                            NativeType::Bool => "%s".to_string(),
                            _ => "%p".to_string(),
                        }
                    };

                    format_str.push_str(&fmt);

                    // Convert bool to string
                    if expr_type == NativeType::Bool {
                        args.push(format!("({} ? \"True\" : \"False\")", expr_code));
                    } else {
                        args.push(expr_code);
                    }
                }
            }
        }

        // Generate sprintf call to temp buffer
        self.temp_counter += 1;
        let temp_var = format!("_fstr_{}", self.temp_counter);

        // Return a compound expression that allocates, formats, and returns the string
        // For simplicity, we'll just return a direct string if no expressions
        if args.is_empty() {
            Ok(format!("\"{}\"", format_str))
        } else {
            // Need to generate a temporary string
            // This requires statement context, so we return a placeholder
            // that indicates this f-string has dynamic parts
            Ok(format!("/* f-string: {} with args: {:?} */", format_str, args))
        }
    }

    fn transpile_function_call(&mut self, func: &Expr, args: &[Expr]) -> Result<String, String> {
        let func_name = if let Expr::Identifier(name) = func {
            name.clone()
        } else {
            return Err("Complex function calls not supported yet".to_string());
        };

        // Handle built-in functions with native implementations
        match func_name.as_str() {
            "print" => return self.generate_print_call(args),
            "len" => {
                if args.len() == 1 {
                    return Ok(format!("strlen({})", self.transpile_expr(&args[0])?));
                }
            }
            "int" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::Int => return Ok(arg_code),
                        NativeType::Float => return Ok(format!("tauraro_int_from_float({})", arg_code)),
                        NativeType::String => return Ok(format!("tauraro_int_from_str({})", arg_code)),
                        NativeType::Bool => return Ok(format!("tauraro_int_from_bool({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "float" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::Float => return Ok(arg_code),
                        NativeType::Int => return Ok(format!("tauraro_float_from_int({})", arg_code)),
                        NativeType::String => return Ok(format!("tauraro_float_from_str({})", arg_code)),
                        NativeType::Bool => return Ok(format!("tauraro_float_from_bool({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "str" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::String => return Ok(format!("tauraro_str_copy({})", arg_code)),
                        NativeType::Int => return Ok(format!("tauraro_str_from_int({})", arg_code)),
                        NativeType::Float => return Ok(format!("tauraro_str_from_float({})", arg_code)),
                        NativeType::Bool => return Ok(format!("tauraro_str_from_bool({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "bool" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::Bool => return Ok(arg_code),
                        NativeType::Int => return Ok(format!("tauraro_bool_from_int({})", arg_code)),
                        NativeType::Float => return Ok(format!("tauraro_bool_from_float({})", arg_code)),
                        NativeType::String => return Ok(format!("tauraro_bool_from_str({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "abs" | "min" | "max" | "round" | "input" | "pow" => {
                // Try to generate optimized built-in call
                let arg_codes: Vec<String> = args.iter()
                    .map(|a| self.transpile_expr(a))
                    .collect::<Result<_, _>>()?;
                let arg_types: Vec<NativeType> = args.iter()
                    .map(|a| self.infer_expr_type(a))
                    .collect::<Result<_, _>>()?;

                if let Some(optimized) = crate::codegen::c_transpiler::native_builtins::generate_builtin_call(
                    &func_name, &arg_codes, &arg_types
                ) {
                    return Ok(optimized);
                }
            }
            _ => {}
        }

        // Regular function call
        let mut code = format!("{}(", func_name);
        for (i, arg) in args.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(&self.transpile_expr(arg)?);
        }
        code.push(')');

        Ok(code)
    }

    fn transpile_range_for(&mut self, loop_var: &str, args: &[Expr], body: &[Statement]) -> Result<String, String> {
        let mut code = self.indent();

        // Parse range arguments
        let (start, end, step) = match args.len() {
            1 => {
                // range(n) -> 0 to n, step 1
                ("0".to_string(), self.transpile_expr(&args[0])?, "1".to_string())
            }
            2 => {
                // range(start, end) -> start to end, step 1
                (self.transpile_expr(&args[0])?, self.transpile_expr(&args[1])?, "1".to_string())
            }
            3 => {
                // range(start, end, step)
                (self.transpile_expr(&args[0])?, self.transpile_expr(&args[1])?, self.transpile_expr(&args[2])?)
            }
            _ => return Err("range() takes 1-3 arguments".to_string()),
        };

        // Register loop variable as int64_t
        self.context.set_variable_type(loop_var.to_string(), NativeType::Int);

        // Generate C for loop
        code.push_str(&format!("for (int64_t {} = {}; {} < {}; {} += {}) {{\n",
            loop_var, start, loop_var, end, loop_var, step));

        self.indent_level += 1;
        for stmt in body {
            code.push_str(&self.transpile_statement(stmt)?);
        }
        self.indent_level -= 1;

        code.push_str(&self.indent());
        code.push_str("}\n");

        Ok(code)
    }

    fn generate_print_call(&mut self, args: &[Expr]) -> Result<String, String> {
        if args.is_empty() {
            return Ok("printf(\"\\n\")".to_string());
        }

        let mut format_str = String::new();
        let mut arg_codes = Vec::new();

        for (i, arg) in args.iter().enumerate() {
            if i > 0 {
                format_str.push(' ');
            }

            let arg_type = self.infer_expr_type(arg)?;
            match arg_type {
                NativeType::Int => format_str.push_str("%lld"),
                NativeType::Float => format_str.push_str("%g"),
                NativeType::Bool => format_str.push_str("%s"),
                NativeType::String => format_str.push_str("%s"),
                _ => format_str.push_str("%p"),
            }

            let mut arg_code = self.transpile_expr(arg)?;
            if arg_type == NativeType::Bool {
                arg_code = format!("({} ? \"True\" : \"False\")", arg_code);
            }
            arg_codes.push(arg_code);
        }

        format_str.push_str("\\n");

        let mut code = format!("printf(\"{}\"", format_str);
        for arg in arg_codes {
            code.push_str(", ");
            code.push_str(&arg);
        }
        code.push(')');

        Ok(code)
    }

    fn transpile_list_comprehension(&mut self, element: &Expr, generators: &[crate::ast::Comprehension]) -> Result<String, String> {
        // List comprehensions are converted to statements, not expressions
        // We'll generate a temporary variable and build up the list
        // For now, return a placeholder that indicates this needs statement context

        // Generate a unique temporary variable name
        self.temp_counter += 1;
        let temp_var = format!("_listcomp_{}", self.temp_counter);
        let temp_size = format!("_listcomp_size_{}", self.temp_counter);
        let temp_capacity = format!("_listcomp_cap_{}", self.temp_counter);

        let mut code = String::new();

        // Infer the element type
        let element_type = self.infer_expr_type(element)?;
        let c_type = element_type.to_c_type();

        // Create the dynamic array
        code.push_str(&format!("({{\\n"));
        code.push_str(&format!("    {}* {} = NULL;\\n", c_type, temp_var));
        code.push_str(&format!("    size_t {} = 0;\\n", temp_size));
        code.push_str(&format!("    size_t {} = 0;\\n", temp_capacity));

        // Generate nested loops for each generator
        for (i, gen) in generators.iter().enumerate() {
            let iter_code = self.transpile_expr(&gen.iter)?;

            // Check if it's a range() call
            if let Expr::Call { func, args, .. } = &gen.iter {
                if let Expr::Identifier(name) = &**func {
                    if name == "range" {
                        // Generate optimized range loop
                        let (start, end, step) = match args.len() {
                            1 => ("0".to_string(), self.transpile_expr(&args[0])?, "1".to_string()),
                            2 => (self.transpile_expr(&args[0])?, self.transpile_expr(&args[1])?, "1".to_string()),
                            3 => (self.transpile_expr(&args[0])?, self.transpile_expr(&args[1])?, self.transpile_expr(&args[2])?),
                            _ => return Err("Invalid range() call".to_string()),
                        };

                        code.push_str(&format!("    for (int64_t {} = {}; {} < {}; {} += {}) {{\\n",
                            gen.target, start, gen.target, end, gen.target, step));
                    } else {
                        return Err("Only range() iterators supported in comprehensions for now".to_string());
                    }
                } else {
                    return Err("Only simple function calls supported in comprehensions".to_string());
                }
            } else {
                return Err("Only range() iterators supported in comprehensions for now".to_string());
            }

            // Add conditional filters
            for if_expr in &gen.ifs {
                let cond_code = self.transpile_expr(if_expr)?;
                code.push_str(&format!("        if ({}) {{\\n", cond_code));
            }
        }

        // Append element to the list
        let element_code = self.transpile_expr(element)?;

        code.push_str(&format!("            if ({} >= {}) {{\\n", temp_size, temp_capacity));
        code.push_str(&format!("                {} = ({} == 0) ? 8 : {} * 2;\\n", temp_capacity, temp_capacity, temp_capacity));
        code.push_str(&format!("                {} = realloc({}, {} * sizeof({}));\\n", temp_var, temp_var, temp_capacity, c_type));
        code.push_str(&format!("            }}\\n"));
        code.push_str(&format!("            {}[{}++] = {};\\n", temp_var, temp_size, element_code));

        // Close all the loops and conditions
        for gen in generators.iter().rev() {
            for _ in &gen.ifs {
                code.push_str(&format!("        }}\\n"));
            }
            code.push_str(&format!("    }}\\n"));
        }

        // Return the list (for now, just the pointer)
        code.push_str(&format!("    {};\\n", temp_var));
        code.push_str(&format!("}})"));

        Ok(code)
    }

    fn transpile_dict_comprehension(&mut self, key: &Expr, value: &Expr, generators: &[crate::ast::Comprehension]) -> Result<String, String> {
        // Dict comprehensions are similar to list comprehensions but create key-value pairs
        // For now, return a placeholder
        Ok("/* dict comprehension not yet implemented */".to_string())
    }

    fn transpile_set_comprehension(&mut self, element: &Expr, generators: &[crate::ast::Comprehension]) -> Result<String, String> {
        // Set comprehensions are similar to list comprehensions
        // For now, return a placeholder
        Ok("/* set comprehension not yet implemented */".to_string())
    }

    fn transpile_try_statement(
        &mut self,
        body: &[Statement],
        except_handlers: &[crate::ast::ExceptHandler],
        else_branch: &Option<Vec<Statement>>,
        finally: &Option<Vec<Statement>>,
        code: &mut String,
    ) -> Result<(), String> {
        // C exception handling using setjmp/longjmp
        // We'll create a jump buffer and exception context

        code.push_str(&self.indent());
        code.push_str("{\n");
        self.indent_level += 1;

        // Create exception handling structure
        code.push_str(&self.indent());
        code.push_str("jmp_buf _exception_buf;\n");
        code.push_str(&self.indent());
        code.push_str("int _exception_code = setjmp(_exception_buf);\n\n");

        code.push_str(&self.indent());
        code.push_str("if (_exception_code == 0) {\n");
        self.indent_level += 1;

        // Try block body
        code.push_str(&self.indent());
        code.push_str("// Try block\n");
        for stmt in body {
            code.push_str(&self.transpile_statement(stmt)?);
        }

        // Else branch (executes if no exception)
        if let Some(else_stmts) = else_branch {
            code.push_str(&self.indent());
            code.push_str("// Else block (no exception)\n");
            for stmt in else_stmts {
                code.push_str(&self.transpile_statement(stmt)?);
            }
        }

        self.indent_level -= 1;
        code.push_str(&self.indent());
        code.push_str("}\n");

        // Except handlers
        for (i, handler) in except_handlers.iter().enumerate() {
            let condition = if i == 0 { "else if" } else { "else if" };

            code.push_str(&self.indent());
            if let Some(_exc_type) = &handler.exception_type {
                // Match specific exception type
                code.push_str(&format!("{} (_exception_code > 0) {{\n", condition));
            } else {
                // Catch-all handler
                code.push_str("else {\n");
            }

            self.indent_level += 1;

            // Bind exception to name if provided
            if let Some(exc_name) = &handler.name {
                code.push_str(&self.indent());
                code.push_str(&format!("// Exception: {}\n", exc_name));
            }

            // Except handler body
            for stmt in &handler.body {
                code.push_str(&self.transpile_statement(stmt)?);
            }

            self.indent_level -= 1;
            code.push_str(&self.indent());
            code.push_str("}\n");
        }

        // Finally block (always executes)
        if let Some(finally_stmts) = finally {
            code.push_str(&self.indent());
            code.push_str("// Finally block (always executes)\n");
            for stmt in finally_stmts {
                code.push_str(&self.transpile_statement(stmt)?);
            }
        }

        self.indent_level -= 1;
        code.push_str(&self.indent());
        code.push_str("}\n");

        Ok(())
    }

    fn transpile_raise_statement(&mut self, exception: &Option<Expr>, code: &mut String) -> Result<(), String> {
        code.push_str(&self.indent());

        if let Some(exc_expr) = exception {
            // Raise specific exception
            let exc_code = self.transpile_expr(exc_expr)?;
            code.push_str(&format!("longjmp(_exception_buf, {});\n", exc_code));
        } else {
            // Re-raise current exception
            code.push_str("longjmp(_exception_buf, 1);\n");
        }

        Ok(())
    }

    fn infer_expr_type(&self, expr: &Expr) -> Result<NativeType, String> {
        Ok(match expr {
            Expr::Literal(Literal::Int(_)) => NativeType::Int,
            Expr::Literal(Literal::Float(_)) => NativeType::Float,
            Expr::Literal(Literal::Bool(_)) => NativeType::Bool,
            Expr::Literal(Literal::String(_)) => NativeType::String,
            Expr::Identifier(name) => {
                self.context.get_variable_type(name)
                    .cloned()
                    .unwrap_or(NativeType::Dynamic)
            }
            Expr::BinaryOp { left, op, .. } => {
                match op {
                    BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Div | BinaryOp::Mod => {
                        self.infer_expr_type(left)?
                    }
                    _ => NativeType::Bool,
                }
            }
            Expr::Compare { .. } => NativeType::Bool,
            _ => NativeType::Dynamic,
        })
    }

    fn map_type_to_native(&self, typ: &Type) -> NativeType {
        match typ {
            Type::Simple(s) => match s.as_str() {
                "int" => NativeType::Int,
                "float" => NativeType::Float,
                "bool" => NativeType::Bool,
                "str" => NativeType::String,
                "None" => NativeType::Void,
                name => NativeType::Struct(name.to_string()),
            },
            Type::Generic { name, args } => {
                if name == "list" && !args.is_empty() {
                    let inner = self.map_type_to_native(&args[0]);
                    NativeType::List(Box::new(inner))
                } else {
                    NativeType::Dynamic
                }
            }
            _ => NativeType::Dynamic,
        }
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transpiler_creation() {
        let transpiler = OptimizedNativeTranspiler::new();
        assert_eq!(transpiler.indent_level, 0);
    }
}
