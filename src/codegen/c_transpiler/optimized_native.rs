//! Optimized Native C Code Generation for Tauraro
//!
//! This module provides high-performance C code generation using native types

use std::collections::HashMap;
use crate::ast::*;
use crate::codegen::c_transpiler::native_types::{NativeType, NativeTypeContext};

pub struct OptimizedNativeTranspiler {
    /// Type context for tracking variable types
    context: NativeTypeContext,
    /// Current indentation level
    indent_level: usize,
    /// Counter for temporary variables
    temp_counter: usize,
}

impl OptimizedNativeTranspiler {
    pub fn new() -> Self {
        Self {
            context: NativeTypeContext::new(),
            indent_level: 0,
            temp_counter: 0,
        }
    }

    /// Generate optimized C code from AST program
    pub fn transpile_program(&mut self, program: &Program) -> Result<String, String> {
        let mut code = String::new();

        // Generate headers
        code.push_str(self.generate_headers().as_str());

        // Generate native type system
        code.push_str(&crate::codegen::c_transpiler::native_types::generate_native_type_declarations());
        code.push_str("\n");

        // Generate forward declarations
        code.push_str("// Forward declarations\n");
        for stmt in &program.statements {
            if let Statement::FunctionDef { name, .. } = stmt {
                code.push_str(&format!("// Function: {}\n", name));
            }
            if let Statement::ClassDef { name, .. } = stmt {
                code.push_str(&format!("typedef struct {} {}_t;\n", name, name));
            }
        }
        code.push_str("\n");

        // Generate classes
        for stmt in &program.statements {
            if let Statement::ClassDef { .. } = stmt {
                code.push_str(&self.transpile_class(stmt)?);
                code.push_str("\n");
            }
        }

        // Generate functions
        for stmt in &program.statements {
            if let Statement::FunctionDef { .. } = stmt {
                code.push_str(&self.transpile_function(stmt)?);
                code.push_str("\n");
            }
        }

        // Generate main function
        code.push_str(&self.generate_main_function(program)?);

        Ok(code)
    }

    fn generate_headers(&self) -> String {
        let mut headers = String::new();
        headers.push_str("// Generated by Tauraro Optimized Native C Transpiler\n");
        headers.push_str("#include <stdio.h>\n");
        headers.push_str("#include <stdlib.h>\n");
        headers.push_str("#include <stdint.h>\n");
        headers.push_str("#include <stdbool.h>\n");
        headers.push_str("#include <string.h>\n");
        headers.push_str("#include <math.h>\n");
        headers.push_str("\n");

        // Add built-in function implementations
        headers.push_str(&crate::codegen::c_transpiler::native_builtins::NativeBuiltins::generate_all_implementations());
        headers.push_str("\n");

        headers
    }

    fn transpile_class(&mut self, stmt: &Statement) -> Result<String, String> {
        if let Statement::ClassDef { name, bases, body, .. } = stmt {
            let mut code = String::new();

            code.push_str(&format!("// Class: {}\n", name));
            code.push_str(&format!("struct {}_t {{\n", name));

            // Add base class field if inheritance
            if !bases.is_empty() {
                if let Expr::Identifier(base_name) = &bases[0] {
                    code.push_str(&format!("    struct {}_t base;\n", base_name));
                }
            }

            // Add reference counting
            code.push_str("    int ref_count;\n");

            // Extract fields from body (simplified)
            code.push_str("    // Fields would be extracted from body\n");

            code.push_str("};\n\n");

            // Constructor and destructor would be generated here

            Ok(code)
        } else {
            Err("Expected ClassDef statement".to_string())
        }
    }

    fn transpile_function(&mut self, stmt: &Statement) -> Result<String, String> {
        if let Statement::FunctionDef { name, params, return_type, body, .. } = stmt {
            let mut code = String::new();

            // Determine return type
            let ret_type = return_type.as_ref()
                .map(|t| self.map_type_to_native(t))
                .unwrap_or(NativeType::Void);

            // Function signature
            code.push_str(&ret_type.to_c_type());
            code.push(' ');
            code.push_str(name);
            code.push('(');

            if params.is_empty() {
                code.push_str("void");
            } else {
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        code.push_str(", ");
                    }

                    let param_type = param.type_annotation.as_ref()
                        .map(|t| self.map_type_to_native(t))
                        .unwrap_or(NativeType::Dynamic);

                    code.push_str(&param_type.to_c_type());
                    code.push(' ');
                    code.push_str(&param.name);

                    // Register parameter type
                    self.context.set_variable_type(param.name.clone(), param_type);
                }
            }

            code.push_str(") {\n");

            // Function body
            self.indent_level += 1;
            for body_stmt in body {
                code.push_str(&self.transpile_statement(body_stmt)?);
            }
            self.indent_level -= 1;

            code.push_str("}\n");

            Ok(code)
        } else {
            Err("Expected FunctionDef statement".to_string())
        }
    }

    fn generate_main_function(&mut self, program: &Program) -> Result<String, String> {
        let mut code = String::new();

        code.push_str("int main(int argc, char** argv) {\n");
        self.indent_level += 1;

        // Transpile top-level statements
        for stmt in &program.statements {
            // Skip function and class definitions
            match stmt {
                Statement::FunctionDef { .. } | Statement::ClassDef { .. } => continue,
                _ => {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
            }
        }

        code.push_str(&self.indent());
        code.push_str("return 0;\n");

        self.indent_level -= 1;
        code.push_str("}\n");

        Ok(code)
    }

    fn transpile_statement(&mut self, stmt: &Statement) -> Result<String, String> {
        let mut code = self.indent();

        match stmt {
            Statement::Expression(expr) => {
                code.push_str(&self.transpile_expr(expr)?);
                code.push_str(";\n");
            }
            Statement::Return(value) => {
                code.push_str("return");
                if let Some(val) = value {
                    code.push(' ');
                    code.push_str(&self.transpile_expr(val)?);
                }
                code.push_str(";\n");
            }
            Statement::If { condition, then_branch, elif_branches, else_branch } => {
                code.push_str(&format!("if ({}) {{\n", self.transpile_expr(condition)?));
                self.indent_level += 1;
                for stmt in then_branch {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
                self.indent_level -= 1;

                // Handle elif branches
                for (elif_cond, elif_body) in elif_branches {
                    code.push_str(&self.indent());
                    code.push_str(&format!("}} else if ({}) {{\n", self.transpile_expr(elif_cond)?));
                    self.indent_level += 1;
                    for stmt in elif_body {
                        code.push_str(&self.transpile_statement(stmt)?);
                    }
                    self.indent_level -= 1;
                }

                if let Some(else_stmts) = else_branch {
                    code.push_str(&self.indent());
                    code.push_str("} else {\n");
                    self.indent_level += 1;
                    for stmt in else_stmts {
                        code.push_str(&self.transpile_statement(stmt)?);
                    }
                    self.indent_level -= 1;
                }

                code.push_str(&self.indent());
                code.push_str("}\n");
            }
            Statement::While { condition, body, else_branch } => {
                code.push_str(&format!("while ({}) {{\n", self.transpile_expr(condition)?));
                self.indent_level += 1;
                for stmt in body {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
                self.indent_level -= 1;
                code.push_str(&self.indent());
                code.push_str("}\n");

                // Note: else_branch on while is Python-specific, would need special handling
                if else_branch.is_some() {
                    code.push_str(&self.indent());
                    code.push_str("/* while-else not yet implemented */\n");
                }
            }
            Statement::For { variable, variables, iterable, body, else_branch } => {
                // Use primary variable or first of variables
                let loop_var = if !variable.is_empty() {
                    variable.clone()
                } else if !variables.is_empty() {
                    variables[0].clone()
                } else {
                    return Err("For loop has no target variable".to_string());
                };

                // Handle range() specially for performance
                if let Expr::Call { func, args, .. } = iterable {
                    if let Expr::Identifier(name) = func.as_ref() {
                        if name == "range" {
                            return self.transpile_range_for(&loop_var, args, body);
                        }
                    }
                }

                code.push_str("/* generic for loop not yet implemented */\n");

                if else_branch.is_some() {
                    code.push_str(&self.indent());
                    code.push_str("/* for-else not yet implemented */\n");
                }
            }
            Statement::VariableDef { name, type_annotation, value } => {
                let var_type = if let Some(typ) = type_annotation {
                    self.map_type_to_native(typ)
                } else if let Some(val) = value {
                    self.infer_expr_type(val)?
                } else {
                    NativeType::Dynamic
                };

                self.context.set_variable_type(name.clone(), var_type.clone());
                code.push_str(&var_type.to_c_type());
                code.push(' ');
                code.push_str(name);

                if let Some(val) = value {
                    code.push_str(" = ");
                    code.push_str(&self.transpile_expr(val)?);
                }
                code.push_str(";\n");
            }
            Statement::AttributeAssignment { object, name, value } => {
                code.push_str(&self.transpile_expr(object)?);
                code.push_str(".");
                code.push_str(name);
                code.push_str(" = ");
                code.push_str(&self.transpile_expr(value)?);
                code.push_str(";\n");
            }
            Statement::SubscriptAssignment { object, index, value } => {
                code.push_str(&self.transpile_expr(object)?);
                code.push('[');
                code.push_str(&self.transpile_expr(index)?);
                code.push_str("] = ");
                code.push_str(&self.transpile_expr(value)?);
                code.push_str(";\n");
            }
            Statement::Break => {
                code.push_str("break;\n");
            }
            Statement::Continue => {
                code.push_str("continue;\n");
            }
            Statement::Pass => {
                code.push_str("/* pass */;\n");
            }
            _ => {
                code.push_str("/* unsupported statement */;\n");
            }
        }

        Ok(code)
    }

    fn transpile_expr(&mut self, expr: &Expr) -> Result<String, String> {
        match expr {
            Expr::Literal(lit) => self.transpile_literal(lit),
            Expr::Identifier(name) => Ok(name.clone()),
            Expr::BinaryOp { left, op, right } => {
                let left_code = self.transpile_expr(left)?;
                let right_code = self.transpile_expr(right)?;
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "pow", // Would need function call
                    _ => "?",
                };
                Ok(format!("({} {} {})", left_code, op_str, right_code))
            }
            Expr::UnaryOp { op, operand } => {
                let operand_code = self.transpile_expr(operand)?;
                let op_str = match op {
                    UnaryOp::Not => "!",
                    UnaryOp::USub => "-",
                    UnaryOp::UAdd => "+",
                    _ => "?",
                };
                Ok(format!("({}{})", op_str, operand_code))
            }
            Expr::Call { func, args, .. } => {
                self.transpile_function_call(func, args)
            }
            Expr::List(items) => {
                let mut code = String::from("{");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        code.push_str(", ");
                    }
                    code.push_str(&self.transpile_expr(item)?);
                }
                code.push('}');
                Ok(code)
            }
            Expr::Subscript { object, index } => {
                Ok(format!("{}[{}]",
                    self.transpile_expr(object)?,
                    self.transpile_expr(index)?))
            }
            Expr::Attribute { object, name } => {
                Ok(format!("{}.{}", self.transpile_expr(object)?, name))
            }
            Expr::Compare { left, ops, comparators } => {
                // Simplified comparison
                if !ops.is_empty() && !comparators.is_empty() {
                    let left_code = self.transpile_expr(left)?;
                    let right_code = self.transpile_expr(&comparators[0])?;
                    let op_str = match &ops[0] {
                        CompareOp::Eq => "==",
                        CompareOp::NotEq => "!=",
                        CompareOp::Lt => "<",
                        CompareOp::LtE => "<=",
                        CompareOp::Gt => ">",
                        CompareOp::GtE => ">=",
                        _ => "==",
                    };
                    Ok(format!("({} {} {})", left_code, op_str, right_code))
                } else {
                    Ok("false".to_string())
                }
            }
            _ => Ok("/* unsupported expr */".to_string()),
        }
    }

    fn transpile_literal(&self, lit: &Literal) -> Result<String, String> {
        Ok(match lit {
            Literal::Int(n) => n.to_string(),
            Literal::Float(f) => f.to_string(),
            Literal::String(s) => format!("\"{}\"", s.replace("\"", "\\\"")),
            Literal::Bool(b) => if *b { "true" } else { "false" }.to_string(),
            Literal::None => "NULL".to_string(),
            _ => "NULL".to_string(),
        })
    }

    fn transpile_function_call(&mut self, func: &Expr, args: &[Expr]) -> Result<String, String> {
        let func_name = if let Expr::Identifier(name) = func {
            name.clone()
        } else {
            return Err("Complex function calls not supported yet".to_string());
        };

        // Handle built-in functions with native implementations
        match func_name.as_str() {
            "print" => return self.generate_print_call(args),
            "len" => {
                if args.len() == 1 {
                    return Ok(format!("strlen({})", self.transpile_expr(&args[0])?));
                }
            }
            "int" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::Int => return Ok(arg_code),
                        NativeType::Float => return Ok(format!("tauraro_int_from_float({})", arg_code)),
                        NativeType::String => return Ok(format!("tauraro_int_from_str({})", arg_code)),
                        NativeType::Bool => return Ok(format!("tauraro_int_from_bool({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "float" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::Float => return Ok(arg_code),
                        NativeType::Int => return Ok(format!("tauraro_float_from_int({})", arg_code)),
                        NativeType::String => return Ok(format!("tauraro_float_from_str({})", arg_code)),
                        NativeType::Bool => return Ok(format!("tauraro_float_from_bool({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "str" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::String => return Ok(format!("tauraro_str_copy({})", arg_code)),
                        NativeType::Int => return Ok(format!("tauraro_str_from_int({})", arg_code)),
                        NativeType::Float => return Ok(format!("tauraro_str_from_float({})", arg_code)),
                        NativeType::Bool => return Ok(format!("tauraro_str_from_bool({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "bool" => {
                if args.len() == 1 {
                    let arg_type = self.infer_expr_type(&args[0])?;
                    let arg_code = self.transpile_expr(&args[0])?;
                    match arg_type {
                        NativeType::Bool => return Ok(arg_code),
                        NativeType::Int => return Ok(format!("tauraro_bool_from_int({})", arg_code)),
                        NativeType::Float => return Ok(format!("tauraro_bool_from_float({})", arg_code)),
                        NativeType::String => return Ok(format!("tauraro_bool_from_str({})", arg_code)),
                        _ => return Ok(arg_code),
                    }
                }
            }
            "abs" | "min" | "max" | "round" | "input" | "pow" => {
                // Try to generate optimized built-in call
                let arg_codes: Vec<String> = args.iter()
                    .map(|a| self.transpile_expr(a))
                    .collect::<Result<_, _>>()?;
                let arg_types: Vec<NativeType> = args.iter()
                    .map(|a| self.infer_expr_type(a))
                    .collect::<Result<_, _>>()?;

                if let Some(optimized) = crate::codegen::c_transpiler::native_builtins::generate_builtin_call(
                    &func_name, &arg_codes, &arg_types
                ) {
                    return Ok(optimized);
                }
            }
            _ => {}
        }

        // Regular function call
        let mut code = format!("{}(", func_name);
        for (i, arg) in args.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(&self.transpile_expr(arg)?);
        }
        code.push(')');

        Ok(code)
    }

    fn transpile_range_for(&mut self, loop_var: &str, args: &[Expr], body: &[Statement]) -> Result<String, String> {
        let mut code = self.indent();

        // Parse range arguments
        let (start, end, step) = match args.len() {
            1 => {
                // range(n) -> 0 to n, step 1
                ("0".to_string(), self.transpile_expr(&args[0])?, "1".to_string())
            }
            2 => {
                // range(start, end) -> start to end, step 1
                (self.transpile_expr(&args[0])?, self.transpile_expr(&args[1])?, "1".to_string())
            }
            3 => {
                // range(start, end, step)
                (self.transpile_expr(&args[0])?, self.transpile_expr(&args[1])?, self.transpile_expr(&args[2])?)
            }
            _ => return Err("range() takes 1-3 arguments".to_string()),
        };

        // Register loop variable as int64_t
        self.context.set_variable_type(loop_var.to_string(), NativeType::Int);

        // Generate C for loop
        code.push_str(&format!("for (int64_t {} = {}; {} < {}; {} += {}) {{\n",
            loop_var, start, loop_var, end, loop_var, step));

        self.indent_level += 1;
        for stmt in body {
            code.push_str(&self.transpile_statement(stmt)?);
        }
        self.indent_level -= 1;

        code.push_str(&self.indent());
        code.push_str("}\n");

        Ok(code)
    }

    fn generate_print_call(&mut self, args: &[Expr]) -> Result<String, String> {
        if args.is_empty() {
            return Ok("printf(\"\\n\")".to_string());
        }

        let mut format_str = String::new();
        let mut arg_codes = Vec::new();

        for (i, arg) in args.iter().enumerate() {
            if i > 0 {
                format_str.push(' ');
            }

            let arg_type = self.infer_expr_type(arg)?;
            match arg_type {
                NativeType::Int => format_str.push_str("%lld"),
                NativeType::Float => format_str.push_str("%g"),
                NativeType::Bool => format_str.push_str("%s"),
                NativeType::String => format_str.push_str("%s"),
                _ => format_str.push_str("%p"),
            }

            let mut arg_code = self.transpile_expr(arg)?;
            if arg_type == NativeType::Bool {
                arg_code = format!("({} ? \"True\" : \"False\")", arg_code);
            }
            arg_codes.push(arg_code);
        }

        format_str.push_str("\\n");

        let mut code = format!("printf(\"{}\"", format_str);
        for arg in arg_codes {
            code.push_str(", ");
            code.push_str(&arg);
        }
        code.push(')');

        Ok(code)
    }

    fn infer_expr_type(&self, expr: &Expr) -> Result<NativeType, String> {
        Ok(match expr {
            Expr::Literal(Literal::Int(_)) => NativeType::Int,
            Expr::Literal(Literal::Float(_)) => NativeType::Float,
            Expr::Literal(Literal::Bool(_)) => NativeType::Bool,
            Expr::Literal(Literal::String(_)) => NativeType::String,
            Expr::Identifier(name) => {
                self.context.get_variable_type(name)
                    .cloned()
                    .unwrap_or(NativeType::Dynamic)
            }
            Expr::BinaryOp { left, op, .. } => {
                match op {
                    BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Div | BinaryOp::Mod => {
                        self.infer_expr_type(left)?
                    }
                    _ => NativeType::Bool,
                }
            }
            Expr::Compare { .. } => NativeType::Bool,
            _ => NativeType::Dynamic,
        })
    }

    fn map_type_to_native(&self, typ: &Type) -> NativeType {
        match typ {
            Type::Simple(s) => match s.as_str() {
                "int" => NativeType::Int,
                "float" => NativeType::Float,
                "bool" => NativeType::Bool,
                "str" => NativeType::String,
                "None" => NativeType::Void,
                name => NativeType::Struct(name.to_string()),
            },
            Type::Generic { name, args } => {
                if name == "list" && !args.is_empty() {
                    let inner = self.map_type_to_native(&args[0]);
                    NativeType::List(Box::new(inner))
                } else {
                    NativeType::Dynamic
                }
            }
            _ => NativeType::Dynamic,
        }
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transpiler_creation() {
        let transpiler = OptimizedNativeTranspiler::new();
        assert_eq!(transpiler.indent_level, 0);
    }
}
