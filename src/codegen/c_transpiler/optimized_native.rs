//! Optimized Native C Code Generation for Tauraro
//!
//! This module provides high-performance C code generation using native types

use std::collections::HashMap;
use crate::ast::*;
use crate::codegen::c_transpiler::native_types::{NativeType, NativeTypeContext};

pub struct OptimizedNativeTranspiler {
    /// Type context for tracking variable types
    context: NativeTypeContext,
    /// Current indentation level
    indent_level: usize,
    /// Counter for temporary variables
    temp_counter: usize,
}

impl OptimizedNativeTranspiler {
    pub fn new() -> Self {
        Self {
            context: NativeTypeContext::new(),
            indent_level: 0,
            temp_counter: 0,
        }
    }

    /// Generate optimized C code from AST program
    pub fn transpile_program(&mut self, program: &Program) -> Result<String, String> {
        let mut code = String::new();

        // Generate headers
        code.push_str(self.generate_headers().as_str());

        // Generate native type system
        code.push_str(&crate::codegen::c_transpiler::native_types::generate_native_type_declarations());
        code.push_str("\n");

        // Generate forward declarations
        code.push_str("// Forward declarations\n");
        for stmt in &program.statements {
            if let Statement::FunctionDef { name, .. } = stmt {
                code.push_str(&format!("// Function: {}\n", name));
            }
            if let Statement::ClassDef { name, .. } = stmt {
                code.push_str(&format!("typedef struct {} {}_t;\n", name, name));
            }
        }
        code.push_str("\n");

        // Generate classes
        for stmt in &program.statements {
            if let Statement::ClassDef { .. } = stmt {
                code.push_str(&self.transpile_class(stmt)?);
                code.push_str("\n");
            }
        }

        // Generate functions
        for stmt in &program.statements {
            if let Statement::FunctionDef { .. } = stmt {
                code.push_str(&self.transpile_function(stmt)?);
                code.push_str("\n");
            }
        }

        // Generate main function
        code.push_str(&self.generate_main_function(program)?);

        Ok(code)
    }

    fn generate_headers(&self) -> String {
        r#"// Generated by Tauraro Optimized Native C Transpiler
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

"#.to_string()
    }

    fn transpile_class(&mut self, stmt: &Statement) -> Result<String, String> {
        if let Statement::ClassDef { name, base, body, .. } = stmt {
            let mut code = String::new();

            code.push_str(&format!("// Class: {}\n", name));
            code.push_str(&format!("struct {} {{\n", name));

            // Add base class field if inheritance
            if let Some(base_name) = base {
                code.push_str(&format!("    struct {}_t base;\n", base_name));
            }

            // Add reference counting
            code.push_str("    int ref_count;\n");

            // Extract fields from body (simplified)
            code.push_str("    // Fields would be extracted from body\n");

            code.push_str("};\n\n");

            // Constructor and destructor would be generated here

            Ok(code)
        } else {
            Err("Expected ClassDef statement".to_string())
        }
    }

    fn transpile_function(&mut self, stmt: &Statement) -> Result<String, String> {
        if let Statement::FunctionDef { name, params, return_type, body, .. } = stmt {
            let mut code = String::new();

            // Determine return type
            let ret_type = return_type.as_ref()
                .map(|t| self.map_type_to_native(t))
                .unwrap_or(NativeType::Void);

            // Function signature
            code.push_str(&ret_type.to_c_type());
            code.push(' ');
            code.push_str(name);
            code.push('(');

            if params.is_empty() {
                code.push_str("void");
            } else {
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        code.push_str(", ");
                    }

                    let param_type = param.type_annotation.as_ref()
                        .map(|t| self.map_type_to_native(t))
                        .unwrap_or(NativeType::Dynamic);

                    code.push_str(&param_type.to_c_type());
                    code.push(' ');
                    code.push_str(&param.name);

                    // Register parameter type
                    self.context.set_variable_type(param.name.clone(), param_type);
                }
            }

            code.push_str(") {\n");

            // Function body
            self.indent_level += 1;
            for body_stmt in body {
                code.push_str(&self.transpile_statement(body_stmt)?);
            }
            self.indent_level -= 1;

            code.push_str("}\n");

            Ok(code)
        } else {
            Err("Expected FunctionDef statement".to_string())
        }
    }

    fn generate_main_function(&mut self, program: &Program) -> Result<String, String> {
        let mut code = String::new();

        code.push_str("int main(int argc, char** argv) {\n");
        self.indent_level += 1;

        // Transpile top-level statements
        for stmt in &program.statements {
            // Skip function and class definitions
            match stmt {
                Statement::FunctionDef { .. } | Statement::ClassDef { .. } => continue,
                _ => {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
            }
        }

        code.push_str(&self.indent());
        code.push_str("return 0;\n");

        self.indent_level -= 1;
        code.push_str("}\n");

        Ok(code)
    }

    fn transpile_statement(&mut self, stmt: &Statement) -> Result<String, String> {
        let mut code = self.indent();

        match stmt {
            Statement::Expression(expr) => {
                code.push_str(&self.transpile_expr(expr)?);
                code.push_str(";\n");
            }
            Statement::Return { value } => {
                code.push_str("return");
                if let Some(val) = value {
                    code.push(' ');
                    code.push_str(&self.transpile_expr(val)?);
                }
                code.push_str(";\n");
            }
            Statement::If { condition, then_block, else_block } => {
                code.push_str(&format!("if ({}) {{\n", self.transpile_expr(condition)?));
                self.indent_level += 1;
                for stmt in then_block {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
                self.indent_level -= 1;

                if let Some(else_stmts) = else_block {
                    code.push_str(&self.indent());
                    code.push_str("} else {\n");
                    self.indent_level += 1;
                    for stmt in else_stmts {
                        code.push_str(&self.transpile_statement(stmt)?);
                    }
                    self.indent_level -= 1;
                }

                code.push_str(&self.indent());
                code.push_str("}\n");
            }
            Statement::While { condition, body } => {
                code.push_str(&format!("while ({}) {{\n", self.transpile_expr(condition)?));
                self.indent_level += 1;
                for stmt in body {
                    code.push_str(&self.transpile_statement(stmt)?);
                }
                self.indent_level -= 1;
                code.push_str(&self.indent());
                code.push_str("}\n");
            }
            Statement::For { target, iter, body } => {
                // Simplified for now - handle range() specially
                code.push_str("/* for loop */\n");
            }
            Statement::Assign { target, value, .. } => {
                // Simplified assignment handling
                if let Expr::Identifier(name) = target {
                    let inferred_type = self.infer_expr_type(value)?;
                    if self.context.get_variable_type(name).is_none() {
                        // New variable - add type declaration
                        self.context.set_variable_type(name.clone(), inferred_type.clone());
                        code.push_str(&inferred_type.to_c_type());
                        code.push(' ');
                    }
                    code.push_str(name);
                    code.push_str(" = ");
                    code.push_str(&self.transpile_expr(value)?);
                    code.push_str(";\n");
                } else {
                    code.push_str("/* complex assignment */;\n");
                }
            }
            Statement::Break => {
                code.push_str("break;\n");
            }
            Statement::Continue => {
                code.push_str("continue;\n");
            }
            Statement::Pass => {
                code.push_str("/* pass */;\n");
            }
            _ => {
                code.push_str("/* unsupported statement */;\n");
            }
        }

        Ok(code)
    }

    fn transpile_expr(&mut self, expr: &Expr) -> Result<String, String> {
        match expr {
            Expr::Literal(lit) => self.transpile_literal(lit),
            Expr::Identifier(name) => Ok(name.clone()),
            Expr::BinaryOp { left, op, right } => {
                let left_code = self.transpile_expr(left)?;
                let right_code = self.transpile_expr(right)?;
                let op_str = match op {
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                    BinaryOp::Mod => "%",
                    BinaryOp::Pow => "pow", // Would need function call
                    _ => "?",
                };
                Ok(format!("({} {} {})", left_code, op_str, right_code))
            }
            Expr::UnaryOp { op, operand } => {
                let operand_code = self.transpile_expr(operand)?;
                let op_str = match op {
                    UnaryOp::Not => "!",
                    UnaryOp::USub => "-",
                    UnaryOp::UAdd => "+",
                    _ => "?",
                };
                Ok(format!("({}{})", op_str, operand_code))
            }
            Expr::Call { func, args, .. } => {
                self.transpile_function_call(func, args)
            }
            Expr::List(items) => {
                let mut code = String::from("{");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        code.push_str(", ");
                    }
                    code.push_str(&self.transpile_expr(item)?);
                }
                code.push('}');
                Ok(code)
            }
            Expr::Subscript { object, index } => {
                Ok(format!("{}[{}]",
                    self.transpile_expr(object)?,
                    self.transpile_expr(index)?))
            }
            Expr::Attribute { object, name } => {
                Ok(format!("{}.{}", self.transpile_expr(object)?, name))
            }
            Expr::Compare { left, ops, comparators } => {
                // Simplified comparison
                if !ops.is_empty() && !comparators.is_empty() {
                    let left_code = self.transpile_expr(left)?;
                    let right_code = self.transpile_expr(&comparators[0])?;
                    let op_str = match &ops[0] {
                        CompareOp::Eq => "==",
                        CompareOp::NotEq => "!=",
                        CompareOp::Lt => "<",
                        CompareOp::LtE => "<=",
                        CompareOp::Gt => ">",
                        CompareOp::GtE => ">=",
                        _ => "==",
                    };
                    Ok(format!("({} {} {})", left_code, op_str, right_code))
                } else {
                    Ok("false".to_string())
                }
            }
            _ => Ok("/* unsupported expr */".to_string()),
        }
    }

    fn transpile_literal(&self, lit: &Literal) -> Result<String, String> {
        Ok(match lit {
            Literal::Int(n) => n.to_string(),
            Literal::Float(f) => f.to_string(),
            Literal::String(s) => format!("\"{}\"", s.replace("\"", "\\\"")),
            Literal::Bool(b) => if *b { "true" } else { "false" }.to_string(),
            Literal::None => "NULL".to_string(),
            _ => "NULL".to_string(),
        })
    }

    fn transpile_function_call(&mut self, func: &Expr, args: &[Expr]) -> Result<String, String> {
        let func_name = if let Expr::Identifier(name) = func {
            name.clone()
        } else {
            return Err("Complex function calls not supported yet".to_string());
        };

        // Handle built-in functions with native implementations
        match func_name.as_str() {
            "print" => return self.generate_print_call(args),
            "len" => {
                if args.len() == 1 {
                    return Ok(format!("strlen({})", self.transpile_expr(&args[0])?));
                }
            }
            "int" | "float" | "str" | "bool" => {
                // Type conversion functions
                if args.len() == 1 {
                    return Ok(self.transpile_expr(&args[0])?);
                }
            }
            _ => {}
        }

        // Regular function call
        let mut code = format!("{}(", func_name);
        for (i, arg) in args.iter().enumerate() {
            if i > 0 {
                code.push_str(", ");
            }
            code.push_str(&self.transpile_expr(arg)?);
        }
        code.push(')');

        Ok(code)
    }

    fn generate_print_call(&mut self, args: &[Expr]) -> Result<String, String> {
        if args.is_empty() {
            return Ok("printf(\"\\n\")".to_string());
        }

        let mut format_str = String::new();
        let mut arg_codes = Vec::new();

        for (i, arg) in args.iter().enumerate() {
            if i > 0 {
                format_str.push(' ');
            }

            let arg_type = self.infer_expr_type(arg)?;
            match arg_type {
                NativeType::Int => format_str.push_str("%lld"),
                NativeType::Float => format_str.push_str("%g"),
                NativeType::Bool => format_str.push_str("%s"),
                NativeType::String => format_str.push_str("%s"),
                _ => format_str.push_str("%p"),
            }

            let mut arg_code = self.transpile_expr(arg)?;
            if arg_type == NativeType::Bool {
                arg_code = format!("({} ? \"True\" : \"False\")", arg_code);
            }
            arg_codes.push(arg_code);
        }

        format_str.push_str("\\n");

        let mut code = format!("printf(\"{}\"", format_str);
        for arg in arg_codes {
            code.push_str(", ");
            code.push_str(&arg);
        }
        code.push(')');

        Ok(code)
    }

    fn infer_expr_type(&self, expr: &Expr) -> Result<NativeType, String> {
        Ok(match expr {
            Expr::Literal(Literal::Int(_)) => NativeType::Int,
            Expr::Literal(Literal::Float(_)) => NativeType::Float,
            Expr::Literal(Literal::Bool(_)) => NativeType::Bool,
            Expr::Literal(Literal::String(_)) => NativeType::String,
            Expr::Identifier(name) => {
                self.context.get_variable_type(name)
                    .cloned()
                    .unwrap_or(NativeType::Dynamic)
            }
            Expr::BinaryOp { left, op, .. } => {
                match op {
                    BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Div | BinaryOp::Mod => {
                        self.infer_expr_type(left)?
                    }
                    _ => NativeType::Bool,
                }
            }
            Expr::Compare { .. } => NativeType::Bool,
            _ => NativeType::Dynamic,
        })
    }

    fn map_type_to_native(&self, typ: &Type) -> NativeType {
        match typ {
            Type::Simple(s) => match s.as_str() {
                "int" => NativeType::Int,
                "float" => NativeType::Float,
                "bool" => NativeType::Bool,
                "str" => NativeType::String,
                "None" => NativeType::Void,
                name => NativeType::Struct(name.to_string()),
            },
            Type::Generic { name, args } => {
                if name == "list" && !args.is_empty() {
                    let inner = self.map_type_to_native(&args[0]);
                    NativeType::List(Box::new(inner))
                } else {
                    NativeType::Dynamic
                }
            }
            _ => NativeType::Dynamic,
        }
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transpiler_creation() {
        let transpiler = OptimizedNativeTranspiler::new();
        assert_eq!(transpiler.indent_level, 0);
    }
}
