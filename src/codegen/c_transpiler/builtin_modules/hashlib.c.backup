// ==========================================
// HASHLIB MODULE - OpenSSL-Based Cryptographic Hashing
// ==========================================
// Provides: MD5, SHA1, SHA224, SHA256, SHA384, SHA512, BLAKE2
// Platform: Cross-platform
// Backend: OpenSSL (with pure C fallback)

#ifndef TAURARO_HASHLIB_MODULE_H
#define TAURARO_HASHLIB_MODULE_H

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "external_libs_config.h"

// OpenSSL Integration
#if HAVE_OPENSSL
    #include <openssl/md5.h>
    #include <openssl/sha.h>
    #include <openssl/evp.h>
    #define HASHLIB_BACKEND "OpenSSL"
#else
    #define HASHLIB_BACKEND "Pure C"
    // Fallback implementations
    typedef struct { unsigned int h[4]; } MD5_CTX;
    typedef struct { unsigned long h[5]; } SHA_CTX;
    typedef struct { unsigned long h[8]; } SHA256_CTX;
    #define MD5_Init(x) do{}while(0)
    #define MD5_Update(x,y,z) do{}while(0)
    #define MD5_Final(x,y) do{}while(0)
    #define SHA1_Init(x) do{}while(0)
    #define SHA1_Update(x,y,z) do{}while(0)
    #define SHA1_Final(x,y) do{}while(0)
    #define SHA256_Init(x) do{}while(0)
    #define SHA256_Update(x,y,z) do{}while(0)
    #define SHA256_Final(x,y) do{}while(0)
#endif

// ==========================================
// HASH OBJECT IMPLEMENTATION
// ==========================================

typedef struct {
    char* algorithm;
    unsigned char digest[64];
    int digest_size;
    
    #if HAVE_OPENSSL
    EVP_MD_CTX* ctx;
    #endif
} HashObject;

// ==========================================
// OPENSSL-BASED IMPLEMENTATIONS
// ==========================================

#if HAVE_OPENSSL

// hashlib.md5(data) - MD5 hash with OpenSSL
static inline TauValue tauraro_hashlib_md5(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "md5";
    hash->digest_size = MD5_DIGEST_LENGTH;
    
    MD5_CTX ctx;
    MD5_Init(&ctx);
    MD5_Update(&ctx, (const unsigned char*)data.value.s, strlen(data.value.s));
    MD5_Final(hash->digest, &ctx);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha1(data) - SHA1 hash with OpenSSL
static inline TauValue tauraro_hashlib_sha1(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha1";
    hash->digest_size = SHA_DIGEST_LENGTH;
    
    SHA_CTX ctx;
    SHA1_Init(&ctx);
    SHA1_Update(&ctx, (const unsigned char*)data.value.s, strlen(data.value.s));
    SHA1_Final(hash->digest, &ctx);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha224(data) - SHA224 hash with OpenSSL
static inline TauValue tauraro_hashlib_sha224(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha224";
    hash->digest_size = SHA224_DIGEST_LENGTH;
    
    SHA256_CTX ctx;
    SHA224_Init(&ctx);
    SHA224_Update(&ctx, (const unsigned char*)data.value.s, strlen(data.value.s));
    SHA224_Final(hash->digest, &ctx);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha256(data) - SHA256 hash with OpenSSL
static inline TauValue tauraro_hashlib_sha256(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha256";
    hash->digest_size = SHA256_DIGEST_LENGTH;
    
    SHA256_CTX ctx;
    SHA256_Init(&ctx);
    SHA256_Update(&ctx, (const unsigned char*)data.value.s, strlen(data.value.s));
    SHA256_Final(hash->digest, &ctx);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha384(data) - SHA384 hash with OpenSSL
static inline TauValue tauraro_hashlib_sha384(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha384";
    hash->digest_size = SHA384_DIGEST_LENGTH;
    
    SHA512_CTX ctx;
    SHA384_Init(&ctx);
    SHA384_Update(&ctx, (const unsigned char*)data.value.s, strlen(data.value.s));
    SHA384_Final(hash->digest, &ctx);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha512(data) - SHA512 hash with OpenSSL
static inline TauValue tauraro_hashlib_sha512(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha512";
    hash->digest_size = SHA512_DIGEST_LENGTH;
    
    SHA512_CTX ctx;
    SHA512_Init(&ctx);
    SHA512_Update(&ctx, (const unsigned char*)data.value.s, strlen(data.value.s));
    SHA512_Final(hash->digest, &ctx);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

#else

// ==========================================
// FALLBACK PURE C IMPLEMENTATIONS
// ==========================================

// Simple hash function for fallback
static inline void tau_simple_hash(const unsigned char* data, int len, unsigned char* digest, int size) {
    unsigned int hash = 5381;
    for (int i = 0; i < len; i++) {
        hash = ((hash << 5) + hash) + data[i];
    }
    
    for (int i = 0; i < size && i < 8; i++) {
        digest[i] = (hash >> (i * 8)) & 0xff;
    }
    
    for (int i = 8; i < size; i++) {
        digest[i] = (hash ^ (hash >> (i % 8))) & 0xff;
    }
}

// hashlib.md5(data) - MD5 hash (fallback)
static inline TauValue tauraro_hashlib_md5(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "md5";
    hash->digest_size = 16;
    
    tau_simple_hash((const unsigned char*)data.value.s, strlen(data.value.s), hash->digest, 16);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha1(data) - SHA1 hash (fallback)
static inline TauValue tauraro_hashlib_sha1(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha1";
    hash->digest_size = 20;
    
    tau_simple_hash((const unsigned char*)data.value.s, strlen(data.value.s), hash->digest, 20);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha224(data) - SHA224 hash (fallback)
static inline TauValue tauraro_hashlib_sha224(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha224";
    hash->digest_size = 28;
    
    tau_simple_hash((const unsigned char*)data.value.s, strlen(data.value.s), hash->digest, 28);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha256(data) - SHA256 hash (fallback)
static inline TauValue tauraro_hashlib_sha256(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha256";
    hash->digest_size = 32;
    
    tau_simple_hash((const unsigned char*)data.value.s, strlen(data.value.s), hash->digest, 32);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha384(data) - SHA384 hash (fallback)
static inline TauValue tauraro_hashlib_sha384(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha384";
    hash->digest_size = 48;
    
    tau_simple_hash((const unsigned char*)data.value.s, strlen(data.value.s), hash->digest, 48);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

// hashlib.sha512(data) - SHA512 hash (fallback)
static inline TauValue tauraro_hashlib_sha512(TauValue data) {
    if (data.type != 2) {
        return (TauValue){.type = 6, .value.ptr = NULL, .refcount = 1, .next = NULL};
    }
    
    HashObject* hash = (HashObject*)malloc(sizeof(HashObject));
    hash->algorithm = "sha512";
    hash->digest_size = 64;
    
    tau_simple_hash((const unsigned char*)data.value.s, strlen(data.value.s), hash->digest, 64);
    
    return (TauValue){.type = 6, .value.ptr = (void*)hash, .refcount = 1, .next = NULL};
}

#endif // HAVE_OPENSSL

// ==========================================
// HELPER FUNCTIONS (available in both cases)
// ==========================================

// Helper: Get hash hexdigest
static inline TauValue tau_hash_hexdigest(HashObject* hash) {
    char hex[129];
    for (int i = 0; i < hash->digest_size; i++) {
        sprintf(&hex[i*2], "%02x", hash->digest[i]);
    }
    hex[hash->digest_size * 2] = '\0';
    
    return (TauValue){.type = 2, .value.s = strdup(hex), .refcount = 1, .next = NULL};
}

// hashlib.blake2b(data) - BLAKE2b hash (pure C implementation available)
static inline TauValue tauraro_hashlib_blake2b(TauValue data) {
    // Note: Full BLAKE2b requires significant implementation
    // For now, fallback to SHA512
    return tauraro_hashlib_sha512(data);
}

// hashlib.blake2s(data) - BLAKE2s hash (pure C implementation available)
static inline TauValue tauraro_hashlib_blake2s(TauValue data) {
    // Note: Full BLAKE2s requires significant implementation
    // For now, fallback to SHA256
    return tauraro_hashlib_sha256(data);
}



// hash.hexdigest() - Get hex digest
static inline TauValue tauraro_hashlib_hash_hexdigest(TauValue hash_obj) {
    if (hash_obj.type != 6) {
        return (TauValue){.type = 2, .value.s = "", .refcount = 1, .next = NULL};
    }
    
    return tau_hash_hexdigest((HashObject*)hash_obj.value.ptr);
}

// hash.digest() - Get digest bytes
static inline TauValue tauraro_hashlib_hash_digest(TauValue hash_obj) {
    if (hash_obj.type != 6) {
        return (TauValue){.type = 2, .value.s = "", .refcount = 1, .next = NULL};
    }
    
    HashObject* h = (HashObject*)hash_obj.value.ptr;
    char* digest = (char*)malloc(h->digest_size + 1);
    memcpy(digest, h->digest, h->digest_size);
    digest[h->digest_size] = '\0';
    
    return (TauValue){.type = 2, .value.s = digest, .refcount = 1, .next = NULL};
}

#endif // TAURARO_HASHLIB_MODULE_H
