//! C ABI code generator for interoperability and exports
use crate::ir::{IRModule, IRFunction, IRType, IRValue};
use crate::codegen::{CodeGenerator, CodegenOptions, Target};
use anyhow::Result;

/// C ABI code generator
pub struct CABICodeGenerator;

impl CABICodeGenerator {
    pub fn new() -> Self {
        Self
    }
    
    /// Generate C header for exported functions
    pub fn generate_exports(module: IRModule) -> Result<String> {
        let mut header = String::from("// Generated by TauraroLang C ABI Export\n\n");
        header.push_str("#ifndef TAURARO_EXPORTS_H\n");
        header.push_str("#define TAURARO_EXPORTS_H\n\n");
        header.push_str("#include <stdint.h>\n");
        header.push_str("#include <stdbool.h>\n\n");
        header.push_str("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
        
        // Generate type definitions for Tauraro types
        header.push_str("// TauraroLang type definitions\n");
        header.push_str("typedef int64_t tauraro_int;\n");
        header.push_str("typedef double tauraro_float;\n");
        header.push_str("typedef bool tauraro_bool;\n");
        header.push_str("typedef const char* tauraro_string;\n");
        header.push_str("typedef void* tauraro_any;\n\n");
        
        // Generate function declarations
        for function in module.functions {
            if function.name.starts_with("export_") || function.name.starts_with("_export") {
                header.push_str(&self.function_to_c_declaration(&function));
                header.push_str(";\n");
            }
        }
        
        // Generate async function declarations
        header.push_str("\n// Async function support\n");
        header.push_str("typedef struct tauraro_async_task tauraro_async_task;\n");
        header.push_str("tauraro_async_task* tauraro_async_create(void* function, void* context);\n");
        header.push_str("bool tauraro_async_poll(tauraro_async_task* task);\n");
        header.push_str("void* tauraro_async_get_result(tauraro_async_task* task);\n");
        header.push_str("void tauraro_async_free(tauraro_async_task* task);\n\n");
        
        header.push_str("#ifdef __cplusplus\n}\n#endif\n");
        header.push_str("#endif // TAURARO_EXPORTS_H\n");
        
        Ok(header)
    }
    
    /// Convert Tauraro function to C declaration
    fn function_to_c_declaration(&self, function: &IRFunction) -> String {
        let return_type = self.ir_type_to_c(&function.return_type);
        let params: Vec<String> = function.parameters
            .iter()
            .map(|(name, ty)| {
                format!("{} {}", self.ir_type_to_c(ty), name)
            })
            .collect();
        
        let c_name = self.mangle_function_name(&function.name);
        
        if function.is_async {
            // Async functions return a task handle
            format!("tauraro_async_task* {}({})", c_name, params.join(", "))
        } else {
            format!("{} {}({})", return_type, c_name, params.join(", "))
        }
    }
    
    /// Convert IR type to C type
    fn ir_type_to_c(&self, ir_type: &IRType) -> &str {
        match ir_type {
            IRType::I8 | IRType::I16 | IRType::I32 | IRType::I64 => "tauraro_int",
            IRType::F32 | IRType::F64 => "tauraro_float",
            IRType::Bool => "tauraro_bool",
            IRType::Pointer(_) => "void*",
            IRType::Void => "void",
            _ => "tauraro_any", // Complex types as generic handle
        }
    }
    
    /// Mangle function name for C compatibility
    fn mangle_function_name(&self, name: &str) -> String {
        name.replace("::", "_")
            .replace("<", "_")
            .replace(">", "_")
            .replace(", ", "_")
            .chars()
            .map(|c| if c.is_alphanumeric() { c } else { '_' })
            .collect()
    }
    
    /// Generate C implementation for async functions
    fn generate_async_c_implementation(&self, function: &IRFunction) -> String {
        let c_name = self.mangle_function_name(&function.name);
        let state_machine_name = format!("{}_state_machine", c_name);
        
        format!(r#"
// Async function implementation for {}
typedef struct {{
    int state;
    void* data;
}} {}_context;

static bool {}({}_context* ctx) {{
    switch(ctx->state) {{
        case 0:
            // Initial state
            ctx->state = 1;
            return false; // Not completed
        case 1:
            // Resume state
            ctx->state = 2;
            return false;
        case 2:
            // Final state
            return true; // Completed
        default:
            return true;
    }}
}}

tauraro_async_task* {}(void* function, void* context) {{
    // Create async task
    tauraro_async_task* task = (tauraro_async_task*)malloc(sizeof(tauraro_async_task));
    task->function = function;
    task->context = context;
    task->completed = false;
    return task;
}}
"#, function.name, c_name, state_machine_name, c_name, c_name)
    }
}

impl CodeGenerator for CABICodeGenerator {
    fn generate(&self, module: IRModule, options: &CodegenOptions) -> Result<Vec<u8>> {
        let mut c_code = String::from("// Generated by TauraroLang C ABI Generator\n\n");
        
        c_code.push_str("#include \"tauraro_exports.h\"\n");
        c_code.push_str("#include <stdlib.h>\n");
        c_code.push_str("#include <string.h>\n\n");
        
        // Generate memory management functions
        c_code.push_str("// Memory management functions\n");
        c_code.push_str(&self.generate_memory_functions());
        c_code.push_str("\n");
        
        // Generate type conversion functions
        c_code.push_str("// Type conversion functions\n");
        c_code.push_str(&self.generate_conversion_functions());
        c_code.push_str("\n");
        
        // Generate function implementations
        for function in module.functions {
            c_code.push_str(&self.function_to_c_implementation(&function));
            c_code.push_str("\n");
        }
        
        // Generate async runtime
        if module.functions.iter().any(|f| f.is_async) {
            c_code.push_str("// Async runtime implementation\n");
            c_code.push_str(&self.generate_async_runtime());
            c_code.push_str("\n");
        }
        
        Ok(c_code.into_bytes())
    }
    
    fn get_target(&self) -> Target {
        Target::C
    }
}

impl CABICodeGenerator {
    fn generate_memory_functions(&self) -> String {
        r#"
// Automatic memory management
typedef struct {
    void* ptr;
    size_t size;
    int ref_count;
} tauraro_alloc;

tauraro_alloc* tauraro_alloc_create(size_t size) {
    tauraro_alloc* alloc = (tauraro_alloc*)malloc(sizeof(tauraro_alloc));
    alloc->ptr = malloc(size);
    alloc->size = size;
    alloc->ref_count = 1;
    return alloc;
}

void tauraro_alloc_retain(tauraro_alloc* alloc) {
    if (alloc) alloc->ref_count++;
}

void tauraro_alloc_release(tauraro_alloc* alloc) {
    if (alloc && --alloc->ref_count == 0) {
        free(alloc->ptr);
        free(alloc);
    }
}

// Manual memory management
void* tauraro_malloc(size_t size) {
    return malloc(size);
}

void tauraro_free(void* ptr) {
    free(ptr);
}
"#.to_string()
    }
    
    fn generate_conversion_functions(&self) -> String {
        r#"
// Type conversion between Tauraro and C
tauraro_string tauraro_int_to_string(tauraro_int value) {
    static char buffer[64];
    snprintf(buffer, sizeof(buffer), "%lld", (long long)value);
    return buffer;
}

tauraro_string tauraro_float_to_string(tauraro_float value) {
    static char buffer[64];
    snprintf(buffer, sizeof(buffer), "%g", value);
    return buffer;
}

tauraro_int tauraro_string_to_int(tauraro_string str) {
    return atoll(str);
}

tauraro_float tauraro_string_to_float(tauraro_string str) {
    return atof(str);
}
"#.to_string()
    }
    
    fn function_to_c_implementation(&self, function: &IRFunction) -> String {
        if function.is_async {
            return self.generate_async_c_implementation(function);
        }
        
        let return_type = self.ir_type_to_c(&function.return_type);
        let c_name = self.mangle_function_name(&function.name);
        let params: Vec<String> = function.parameters
            .iter()
            .map(|(name, ty)| {
                format!("{} {}", self.ir_type_to_c(ty), name)
            })
            .collect();
        
        let mut implementation = format!("{} {}({}) {{\n", return_type, c_name, params.join(", "));
        
        // Generate function body based on IR
        implementation.push_str("    // Generated function body\n");
        
        // Add type annotations for static typing support
        if function.parameters.iter().any(|(_, ty)| !matches!(ty, IRType::Void)) {
            implementation.push_str("    // Static type annotations enforced\n");
        }
        
        // Add return statement based on return type
        match &function.return_type {
            IRType::Void => implementation.push_str("    return;\n"),
            IRType::I64 => implementation.push_str("    return 0;\n"),
            IRType::F64 => implementation.push_str("    return 0.0;\n"),
            IRType::Bool => implementation.push_str("    return false;\n"),
            _ => implementation.push_str("    return NULL;\n"),
        };
        
        implementation.push_str("}\n");
        implementation
    }
    
    fn generate_async_runtime(&self) -> String {
        r#"
// Async task implementation
struct tauraro_async_task {
    void* function;
    void* context;
    bool completed;
    void* result;
};

tauraro_async_task* tauraro_async_create(void* function, void* context) {
    tauraro_async_task* task = (tauraro_async_task*)malloc(sizeof(tauraro_async_task));
    task->function = function;
    task->context = context;
    task->completed = false;
    task->result = NULL;
    return task;
}

bool tauraro_async_poll(tauraro_async_task* task) {
    if (!task || task->completed) return true;
    
    // Call state machine function
    typedef bool (*state_machine_fn)(void*);
    state_machine_fn fn = (state_machine_fn)task->function;
    task->completed = fn(task->context);
    
    return task->completed;
}

void* tauraro_async_get_result(tauraro_async_task* task) {
    return task ? task->result : NULL;
}

void tauraro_async_free(tauraro_async_task* task) {
    if (task) {
        free(task->context);
        free(task);
    }
}
"#.to_string()
    }
}