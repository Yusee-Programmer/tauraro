//! Rust Project Generator for Tauraro
//!
//! This module handles generating a complete Cargo project structure
//! from Tauraro IR code, with proper separation of concerns:
//! - lib.rs: Core types (TauObject) and builtin functions
//! - generated.rs: User-defined functions and classes
//! - main.rs: Entry point that orchestrates everything

use anyhow::Result;
use std::path::{Path, PathBuf};
use std::fs;

pub struct ProjectGenerator {
    output_dir: PathBuf,
    project_name: String,
}

impl ProjectGenerator {
    pub fn new(output_dir: PathBuf, project_name: String) -> Self {
        Self {
            output_dir,
            project_name,
        }
    }

    /// Create the full project structure
    pub fn create_project(&self) -> Result<PathBuf> {
        let project_root = self.output_dir.join("rust");
        
        // Create directory structure
        fs::create_dir_all(project_root.join("src"))?;
        fs::create_dir_all(project_root.join("target"))?;
        
        Ok(project_root)
    }

    /// Generate Cargo.toml
    pub fn generate_cargo_toml(&self, project_root: &Path, package_name: &str) -> Result<()> {
        let cargo_content = format!(
            r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[dependencies]

[profile.release]
opt-level = 3
lto = true
"#,
            package_name
        );

        fs::write(project_root.join("Cargo.toml"), cargo_content)?;
        Ok(())
    }

    /// Generate lib.rs with TauObject and all builtins
    pub fn generate_lib_rs(&self, project_root: &Path, lib_code: &str) -> Result<()> {
        let lib_path = project_root.join("src").join("lib.rs");
        fs::write(&lib_path, lib_code)?;
        Ok(())
    }

    /// Generate generated.rs with user code
    pub fn generate_generated_rs(&self, project_root: &Path, user_code: &str) -> Result<()> {
        let generated_path = project_root.join("src").join("generated.rs");
        fs::write(&generated_path, user_code)?;
        Ok(())
    }

    /// Generate main.rs that ties everything together
    pub fn generate_main_rs(&self, project_root: &Path) -> Result<()> {
        let main_content = r#"// Generated by Tauraro Rust Transpiler
// This is the entry point for the compiled Tauraro program

mod generated;
use generated::*;

fn main() {
    // Call the generated main function if it exists
    if let std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        generated::main_function();
    })).is_err() {
        eprintln!("Runtime error in generated code");
    }
}
"#;

        let main_path = project_root.join("src").join("main.rs");
        fs::write(&main_path, main_content)?;
        Ok(())
    }

    /// Generate .gitignore for the project
    pub fn generate_gitignore(&self, project_root: &Path) -> Result<()> {
        let gitignore_content = r#"/target/
Cargo.lock
*.swp
*.swo
*~
.DS_Store
"#;

        fs::write(project_root.join(".gitignore"), gitignore_content)?;
        Ok(())
    }
}

/// Split generated Rust code into lib and user code
pub fn split_rust_code(full_code: &str) -> (String, String) {
    // Separate the TauObject enum, TauObject impl blocks, and builtin functions
    // from user-defined functions
    
    let mut lib_code = String::new();
    let mut generated_code = String::new();
    
    let lines: Vec<&str> = full_code.lines().collect();
    let mut i = 0;
    let mut in_user_code = false;
    
    // Add imports to lib
    let imports = vec![
        "use std::collections::HashMap;",
        "use std::sync::{Arc, Mutex};",
        "use std::any::Any;",
    ];
    
    for import in imports {
        lib_code.push_str(import);
        lib_code.push('\n');
    }
    lib_code.push('\n');
    
    // Process the full code, separating builtins from user code
    while i < lines.len() {
        let line = lines[i];
        
        // Check if this is the start of user function definitions
        // (after all TauObject and builtin code)
        if line.starts_with("fn ") && !line.contains("tau_") && !line.contains("__") 
            && !line.starts_with("fn main") {
            in_user_code = true;
        }
        
        if in_user_code {
            generated_code.push_str(line);
        } else {
            lib_code.push_str(line);
        }
        
        lib_code.push('\n');
        i += 1;
    }
    
    (lib_code, generated_code)
}
