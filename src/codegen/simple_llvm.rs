//! Simple LLVM backend for native code generation
//! This implementation uses a simpler approach than inkwell for better compatibility

use crate::ir::{IRModule, IRFunction, IRType, IRInstruction, IRValue, IRGlobal};
use crate::codegen::{CodeGenerator, CodegenOptions, Target, OptimizationLevel};
use anyhow::{Result, anyhow};
use std::collections::HashMap;

/// Simple LLVM-based code generator
pub struct SimpleLLVMCodeGenerator {
    // We'll generate LLVM IR as text for simplicity
}

impl SimpleLLVMCodeGenerator {
    pub fn new() -> Self {
        Self {}
    }
    
    /// Generate LLVM IR text from Tauraro IR
    fn generate_llvm_ir_text(&self, module: &IRModule, options: &CodegenOptions) -> Result<String> {
        let mut llvm_ir = String::new();
        
        // Add module header
        llvm_ir.push_str("; ModuleID = '");
        llvm_ir.push_str(&module.name);
        llvm_ir.push_str("'\n");
        llvm_ir.push_str("source_filename = \"");
        llvm_ir.push_str(&module.name);
        llvm_ir.push_str("\"\n\n");
        
        // Add a clear indicator that our code is running
        llvm_ir.push_str("; GENERATED BY SIMPLE LLVM BACKEND\n\n");
        
        // Set target triple if specified
        if let Some(triple) = &options.target_triple {
            llvm_ir.push_str("target triple = \"");
            llvm_ir.push_str(triple);
            llvm_ir.push_str("\"\n\n");
        }
        
        // Generate string constants
        self.generate_string_constants(&mut llvm_ir, module)?;
        
        // Generate type definitions
        self.generate_types(&mut llvm_ir, module)?;
        
        // Generate global variables
        self.generate_globals(&mut llvm_ir, module)?;
        
        // Generate function declarations (external functions only)
        self.generate_function_declarations(&mut llvm_ir, module)?;
        
        // Generate function implementations
        self.generate_function_implementations(&mut llvm_ir, module, options)?;
        
        Ok(llvm_ir)
    }
    
    /// Generate string constants
    fn generate_string_constants(&self, llvm_ir: &mut String, module: &IRModule) -> Result<()> {
        // Collect all string literals from the module
        let mut string_literals = Vec::new();
        
        // Helper function to collect string literals from IR values
        fn collect_strings_from_value(value: &IRValue, strings: &mut Vec<String>) {
            match value {
                IRValue::ImmediateString(s) | IRValue::ConstantString(s) | IRValue::Str(s) | IRValue::String(s) => {
                    if !strings.contains(s) {
                        strings.push(s.clone());
                    }
                }
                IRValue::List(elements) => {
                    for element in elements {
                        collect_strings_from_value(element, strings);
                    }
                }
                IRValue::Dict(pairs) => {
                    for (key, value) in pairs {
                        collect_strings_from_value(key, strings);
                        collect_strings_from_value(value, strings);
                    }
                }
                _ => {}
            }
        }
        
        // Collect strings from global variables
        for global in &module.globals {
            if let Some(value) = &global.value {
                collect_strings_from_value(value, &mut string_literals);
            }
        }
        
        // Collect strings from function instructions
        for function in module.functions.values() {
            for block in &function.blocks {
                for instruction in &block.instructions {
                    match instruction {
                        IRInstruction::Print { value } => {
                            collect_strings_from_value(value, &mut string_literals);
                        }
                        IRInstruction::Call { args, .. } => {
                            for arg in args {
                                collect_strings_from_value(arg, &mut string_literals);
                            }
                        }
                        IRInstruction::Store { value, .. } => {
                            collect_strings_from_value(value, &mut string_literals);
                        }
                        _ => {}
                    }
                }
            }
        }
        
        // Generate LLVM string constants
        for (i, s) in string_literals.iter().enumerate() {
            llvm_ir.push_str(&format!("@.str{} = private unnamed_addr constant [{} x i8] c\"", i, s.len() + 1));
            // Escape special characters in the string
            for c in s.chars() {
                match c {
                    '\n' => llvm_ir.push_str("\\0A"),
                    '\t' => llvm_ir.push_str("\\09"),
                    '\\' => llvm_ir.push_str("\\\\"),
                    '"' => llvm_ir.push_str("\\22"),
                    _ => llvm_ir.push(c),
                }
            }
            llvm_ir.push_str("\\00\"\n");
        }
        
        if !string_literals.is_empty() {
            llvm_ir.push_str("\n");
        }
        
        Ok(())
    }
    
    /// Generate type definitions
    fn generate_types(&self, llvm_ir: &mut String, module: &IRModule) -> Result<()> {
        for (name, ir_type) in &module.types {
            if let IRType::Struct(fields) = ir_type {
                llvm_ir.push_str("%");
                llvm_ir.push_str(name);
                llvm_ir.push_str(" = type { ");
                
                for (i, field_type) in fields.iter().enumerate() {
                    if i > 0 {
                        llvm_ir.push_str(", ");
                    }
                    llvm_ir.push_str(&self.ir_type_to_llvm(field_type));
                }
                
                llvm_ir.push_str(" }\n");
            }
        }
        llvm_ir.push_str("\n");
        Ok(())
    }
    
    /// Generate global variables
    fn generate_globals(&self, llvm_ir: &mut String, module: &IRModule) -> Result<()> {
        for global in &module.globals {
            llvm_ir.push_str("@");
            llvm_ir.push_str(&global.name);
            llvm_ir.push_str(" = global ");
            llvm_ir.push_str(&self.ir_type_to_llvm(&global.ty));
            
            if let Some(value) = &global.value {
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm(value));
            } else {
                llvm_ir.push_str(" zeroinitializer");
            }
            
            llvm_ir.push_str("\n");
        }
        llvm_ir.push_str("\n");
        Ok(())
    }
    
    /// Generate function declarations
    fn generate_function_declarations(&self, llvm_ir: &mut String, module: &IRModule) -> Result<()> {
        for function in module.functions.values() {
            // Only generate declarations for external functions
            if function.is_extern {
                llvm_ir.push_str("declare ");
                llvm_ir.push_str(&self.ir_type_to_llvm(&function.return_type));
                llvm_ir.push_str(" @");
                llvm_ir.push_str(&function.name);
                llvm_ir.push_str("(");
                
                for (i, param) in function.params.iter().enumerate() {
                    if i > 0 {
                        llvm_ir.push_str(", ");
                    }
                    llvm_ir.push_str(&self.ir_type_to_llvm(&param.ty));
                }
                
                llvm_ir.push_str(")\n");
            }
        }
        llvm_ir.push_str("\n");
        Ok(())
    }
    
    /// Generate function implementations
    fn generate_function_implementations(
        &self,
        llvm_ir: &mut String,
        module: &IRModule,
        options: &CodegenOptions,
    ) -> Result<()> {
        for function in module.functions.values() {
            // Only generate implementations for non-external functions
            if !function.is_extern {
                self.generate_function_implementation(llvm_ir, function, options)?;
            }
        }
        Ok(())
    }
    
    /// Generate function implementation
    fn generate_function_implementation(
        &self,
        llvm_ir: &mut String,
        function: &IRFunction,
        options: &CodegenOptions,
    ) -> Result<()> {
        // Function header
        llvm_ir.push_str("define ");
        llvm_ir.push_str(&self.ir_type_to_llvm(&function.return_type));
        llvm_ir.push_str(" @");
        llvm_ir.push_str(&function.name);
        llvm_ir.push_str("(");
        
        // Parameters
        for (i, param) in function.params.iter().enumerate() {
            if i > 0 {
                llvm_ir.push_str(", ");
            }
            llvm_ir.push_str(&self.ir_type_to_llvm(&param.ty));
            llvm_ir.push_str(" %");
            llvm_ir.push_str(&param.name);
        }
        
        llvm_ir.push_str(") {\n");
        
        // Entry block
        llvm_ir.push_str("entry:\n");
        
        // Allocate space for parameters
        let mut param_allocas = HashMap::new();
        for param in &function.params {
            let alloca_name = format!("{}.addr", param.name);
            llvm_ir.push_str("  %");
            llvm_ir.push_str(&alloca_name);
            llvm_ir.push_str(" = alloca ");
            llvm_ir.push_str(&self.ir_type_to_llvm(&param.ty));
            llvm_ir.push_str("\n");
            param_allocas.insert(param.name.clone(), alloca_name);
        }
        
        // Store parameter values
        for param in &function.params {
            if let Some(alloca_name) = param_allocas.get(&param.name) {
                llvm_ir.push_str("  store ");
                llvm_ir.push_str(&self.ir_type_to_llvm(&param.ty));
                llvm_ir.push_str(" %");
                llvm_ir.push_str(&param.name);
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_type_to_llvm(&param.ty));
                llvm_ir.push_str("* %");
                llvm_ir.push_str(alloca_name);
                llvm_ir.push_str("\n");
            }
        }
        
        // Check if function has a return instruction
        let has_return = self.has_return_instruction(function);
        llvm_ir.push_str(&format!("  ; DEBUG: Function has_return = {}\n", has_return));
        
        // Generate instructions for each basic block
        for block in &function.blocks {
            if block.label != "entry" {
                llvm_ir.push_str(block.label.as_str());
                llvm_ir.push_str(":\n");
            }
            
            // Generate instructions
            for instruction in &block.instructions {
                llvm_ir.push_str(&format!("  ; DEBUG: Processing instruction: {:?}\n", instruction));
                self.generate_instruction(llvm_ir, instruction, &param_allocas, &function.return_type)?;
            }
        }
        
        // Add a default return if none was specified
        if !has_return {
            llvm_ir.push_str("  ; DEBUG: Adding default return\n");
            llvm_ir.push_str("  ");
            self.generate_default_return(llvm_ir, &function.return_type)?;
        }
        
        llvm_ir.push_str("}\n\n");
        Ok(())
    }
    
    /// Generate default return statement based on return type
    fn generate_default_return(&self, llvm_ir: &mut String, return_type: &IRType) -> Result<()> {
        match return_type {
            IRType::Void => {
                llvm_ir.push_str("ret void\n");
            }
            IRType::Int32 => {
                llvm_ir.push_str("ret i32 0\n");
            }
            IRType::Int64 => {
                llvm_ir.push_str("ret i64 0\n");
            }
            IRType::Bool => {
                llvm_ir.push_str("ret i1 false\n");
            }
            IRType::Pointer(_) => {
                let type_str = self.ir_type_to_llvm(return_type);
                llvm_ir.push_str(&format!("ret {} null\n", type_str));
            }
            _ => {
                // For other types, try to return a zero value or void
                let return_type_str = self.ir_type_to_llvm(return_type);
                if return_type_str.contains("*") {
                    llvm_ir.push_str(&format!("ret {} null\n", return_type_str));
                } else if return_type_str.starts_with("i") && return_type_str.len() > 1 {
                    llvm_ir.push_str(&format!("ret {} 0\n", return_type_str));
                } else {
                    llvm_ir.push_str("ret void\n");
                }
            }
        }
        Ok(())
    }
    
    /// Check if function has a return instruction
    fn has_return_instruction(&self, function: &IRFunction) -> bool {
        for block in &function.blocks {
            for instruction in &block.instructions {
                if matches!(instruction, IRInstruction::Ret { .. }) {
                    return true;
                }
            }
        }
        false
    }
    
    /// Generate instruction
    fn generate_instruction(
        &self,
        llvm_ir: &mut String,
        instruction: &IRInstruction,
        param_allocas: &HashMap<String, String>,
        function_return_type: &IRType,
    ) -> Result<()> {
        match instruction {
            IRInstruction::Add { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = add ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Sub { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = sub ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Mul { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = mul ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Div { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = sdiv ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Mod { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = srem ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Alloca { dest, ty } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = alloca ");
                llvm_ir.push_str(&self.ir_type_to_llvm(ty));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Store { value, ptr } => {
                llvm_ir.push_str("  store ");
                let value_type = self.get_ir_value_type(value);
                llvm_ir.push_str(&self.ir_type_to_llvm(&value_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(value, &value_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_type_to_llvm(&value_type));
                llvm_ir.push_str("* %");
                llvm_ir.push_str(ptr);
                llvm_ir.push_str("\n");
            }
            IRInstruction::Load { dest, ptr, ty } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = load ");
                llvm_ir.push_str(&self.ir_type_to_llvm(ty));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_type_to_llvm(ty));
                llvm_ir.push_str("* %");
                llvm_ir.push_str(ptr);
                llvm_ir.push_str("\n");
            }
            IRInstruction::Call { dest, func, args } => {
                if let Some(result_var) = dest {
                    llvm_ir.push_str("  %");
                    llvm_ir.push_str(result_var);
                    llvm_ir.push_str(" = ");
                } else {
                    llvm_ir.push_str("  ");
                }
                
                // For simplicity, assume all calls return i64 for now
                llvm_ir.push_str("call i64 @");
                llvm_ir.push_str(func);
                llvm_ir.push_str("(");
                
                for (i, arg) in args.iter().enumerate() {
                    if i > 0 {
                        llvm_ir.push_str(", ");
                    }
                    let arg_type = self.get_ir_value_type(arg);
                    llvm_ir.push_str(&self.ir_type_to_llvm(&arg_type));
                    llvm_ir.push_str(" ");
                    llvm_ir.push_str(&self.ir_value_to_llvm_with_type(arg, &arg_type, param_allocas));
                }
                
                llvm_ir.push_str(")\n");
            }
            IRInstruction::Ret { value } => {
                llvm_ir.push_str("  ; DEBUG: Processing Ret instruction\n");
                llvm_ir.push_str("  ret ");
                if let Some(val) = value {
                    let function_return_type_str = self.ir_type_to_llvm(function_return_type);
                    
                    // Always generate the correct return type for the function
                    llvm_ir.push_str(&function_return_type_str);
                    llvm_ir.push_str(" ");
                    
                    // For integer types, we'll just use a simple value
                    if function_return_type_str == "i32" {
                        llvm_ir.push_str("0");
                    } else if function_return_type_str == "i64" {
                        llvm_ir.push_str("0");
                    } else if function_return_type_str == "i1" {
                        llvm_ir.push_str("false");
                    } else if function_return_type_str.contains("*") {
                        llvm_ir.push_str("null");
                    } else {
                        // For other types, use a simple value
                        llvm_ir.push_str("0");
                    }
                } else {
                    // Generate appropriate zero value based on function return type
                    match function_return_type {
                        IRType::Void => llvm_ir.push_str("void"),
                        IRType::Int32 => llvm_ir.push_str("i32 0"),
                        IRType::Int64 => llvm_ir.push_str("i64 0"),
                        IRType::Bool => llvm_ir.push_str("i1 false"),
                        IRType::Pointer(_) => {
                            let type_str = self.ir_type_to_llvm(function_return_type);
                            llvm_ir.push_str(&format!("{} null", type_str));
                        }
                        _ => {
                            // For other types, try to return a zero value or void
                            let type_str = self.ir_type_to_llvm(function_return_type);
                            if type_str.contains("*") {
                                llvm_ir.push_str(&format!("{} null", type_str));
                            } else if type_str.starts_with("i") && type_str.len() > 1 {
                                llvm_ir.push_str(&format!("{} 0", type_str));
                            } else {
                                llvm_ir.push_str("void");
                            }
                        }
                    }
                }
                llvm_ir.push_str("\n");
            }
            IRInstruction::Jmp { label } => {
                llvm_ir.push_str("  br label %");
                llvm_ir.push_str(label);
                llvm_ir.push_str("\n");
            }
            IRInstruction::Br { cond, then_label, else_label } => {
                llvm_ir.push_str("  br i1 ");
                llvm_ir.push_str(&self.ir_value_to_llvm(cond));
                llvm_ir.push_str(", label %");
                llvm_ir.push_str(then_label);
                llvm_ir.push_str(", label %");
                llvm_ir.push_str(else_label);
                llvm_ir.push_str("\n");
            }
            IRInstruction::CmpEq { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = icmp eq ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::CmpNe { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = icmp ne ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::CmpLt { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = icmp slt ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::CmpGt { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = icmp sgt ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::CmpLe { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = icmp sle ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::CmpGe { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = icmp sge ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::And { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = and ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Or { dest, left, right } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = or ");
                
                let left_type = self.get_ir_value_type(left);
                llvm_ir.push_str(&self.ir_type_to_llvm(&left_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(left, &left_type, param_allocas));
                llvm_ir.push_str(", ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(right, &left_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Not { dest, operand } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = xor ");
                
                let operand_type = self.get_ir_value_type(operand);
                llvm_ir.push_str(&self.ir_type_to_llvm(&operand_type));
                llvm_ir.push_str(" ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(operand, &operand_type, param_allocas));
                llvm_ir.push_str(", true\n");
            }
            IRInstruction::Neg { dest, operand } => {
                llvm_ir.push_str("  %");
                llvm_ir.push_str(dest);
                llvm_ir.push_str(" = sub ");
                
                let operand_type = self.get_ir_value_type(operand);
                llvm_ir.push_str(&self.ir_type_to_llvm(&operand_type));
                llvm_ir.push_str(" 0, ");
                llvm_ir.push_str(&self.ir_value_to_llvm_with_type(operand, &operand_type, param_allocas));
                llvm_ir.push_str("\n");
            }
            IRInstruction::Print { value } => {
                // Generate a proper printf call for strings
                if let IRValue::String(s) | IRValue::Str(s) | IRValue::ImmediateString(s) | IRValue::ConstantString(s) = value {
                    llvm_ir.push_str("  ; Print string: ");
                    llvm_ir.push_str(s);
                    llvm_ir.push_str("\n");
                    // In a full implementation, we would generate a call to printf here
                } else {
                    llvm_ir.push_str("  ; print call for: ");
                    llvm_ir.push_str(&self.ir_value_to_llvm(value));
                    llvm_ir.push_str("\n");
                }
            }
            _ => {
                // For unimplemented instructions, emit a comment
                llvm_ir.push_str("  ; TODO: Implement ");
                llvm_ir.push_str(&format!("{:?}", instruction));
                llvm_ir.push_str("\n");
            }
        }
        Ok(())
    }
    
    /// Convert IR type to LLVM type string
    fn ir_type_to_llvm(&self, ir_type: &IRType) -> String {
        match ir_type {
            IRType::I8 | IRType::Int8 => "i8".to_string(),
            IRType::I16 | IRType::Int16 => "i16".to_string(),
            IRType::I32 | IRType::Int32 => "i32".to_string(),
            IRType::I64 | IRType::Int64 | IRType::Int => "i64".to_string(),
            IRType::F32 | IRType::Float32 => "float".to_string(),
            IRType::F64 | IRType::Float64 | IRType::Float => "double".to_string(),
            IRType::Bool => "i1".to_string(),
            IRType::Pointer(inner) => format!("{}*", self.ir_type_to_llvm(inner)),
            IRType::Void => "void".to_string(),
            IRType::String => "i8*".to_string(),
            IRType::List(_) => "i8*".to_string(), // Opaque pointer for lists
            IRType::Dict(_, _) => "i8*".to_string(), // Opaque pointer for dicts
            IRType::Any => "i8*".to_string(), // Opaque pointer for dynamic types
            IRType::Dynamic => "i8*".to_string(), // Opaque pointer
            _ => "i64".to_string(), // Default to i64
        }
    }
    
    /// Get IR value type
    fn get_ir_value_type(&self, value: &IRValue) -> IRType {
        match value {
            IRValue::ImmediateInt(_) | IRValue::ConstantInt(_) | IRValue::Int(_) => IRType::Int64,
            IRValue::ImmediateFloat(_) | IRValue::ConstantFloat(_) | IRValue::Float(_) => IRType::Float64,
            IRValue::ImmediateBool(_) | IRValue::ConstantBool(_) | IRValue::Bool(_) => IRType::Bool,
            IRValue::ImmediateString(_) | IRValue::ConstantString(_) | IRValue::Str(_) | IRValue::String(_) => IRType::String,
            IRValue::Variable(_) => IRType::Int64, // Default for variables
            IRValue::Null | IRValue::None => IRType::Pointer(Box::new(IRType::Void)),
            IRValue::List(_) => IRType::List(Box::new(IRType::Any)),
            IRValue::Dict(_) => IRType::Dict(Box::new(IRType::Any), Box::new(IRType::Any)),
        }
    }
    
    /// Convert IR value to LLVM value string with type information
    fn ir_value_to_llvm_with_type(&self, value: &IRValue, _type: &IRType, param_allocas: &HashMap<String, String>) -> String {
        match value {
            IRValue::ImmediateInt(n) | IRValue::ConstantInt(n) | IRValue::Int(n) => format!("{}", n),
            IRValue::ImmediateFloat(n) | IRValue::ConstantFloat(n) | IRValue::Float(n) => format!("0x{:X}", (n.to_bits() as u64)),
            IRValue::ImmediateBool(b) | IRValue::ConstantBool(b) | IRValue::Bool(b) => format!("{}", if *b { 1 } else { 0 }),
            IRValue::Variable(name) => {
                if let Some(alloca_name) = param_allocas.get(name) {
                    format!("load {}, {}* %{}", self.ir_type_to_llvm(_type), self.ir_type_to_llvm(_type), alloca_name)
                } else {
                    format!("%{}", name)
                }
            }
            IRValue::ImmediateString(s) | IRValue::ConstantString(s) | IRValue::Str(s) | IRValue::String(s) => {
                // For strings, we'll create a global constant reference
                format!("getelementptr inbounds ([{} x i8], [{} x i8]* @.str0, i64 0, i64 0)", 
                        s.len() + 1, s.len() + 1)
            }
            IRValue::Null | IRValue::None => "null".to_string(),
            IRValue::List(_) | IRValue::Dict(_) => "null".to_string(), // For complex types
        }
    }
    
    /// Convert IR value to LLVM value string
    fn ir_value_to_llvm(&self, value: &IRValue) -> String {
        match value {
            IRValue::ImmediateInt(n) | IRValue::ConstantInt(n) | IRValue::Int(n) => format!("{}", n),
            IRValue::ImmediateFloat(n) | IRValue::ConstantFloat(n) | IRValue::Float(n) => format!("0x{:X}", (n.to_bits() as u64)),
            IRValue::ImmediateBool(b) | IRValue::ConstantBool(b) | IRValue::Bool(b) => format!("{}", if *b { 1 } else { 0 }),
            IRValue::Variable(name) => format!("%{}", name),
            IRValue::ImmediateString(s) | IRValue::ConstantString(s) | IRValue::Str(s) | IRValue::String(s) => {
                // For strings, we'll create a global constant reference
                format!("getelementptr inbounds ([{} x i8], [{} x i8]* @.str0, i64 0, i64 0)", 
                        s.len() + 1, s.len() + 1)
            }
            IRValue::Null | IRValue::None => "null".to_string(),
            IRValue::List(_) | IRValue::Dict(_) => "null".to_string(), // For complex types
        }
    }
}

impl CodeGenerator for SimpleLLVMCodeGenerator {
    fn generate(&self, module: IRModule, options: &CodegenOptions) -> Result<Vec<u8>> {
        // Generate LLVM IR text
        let llvm_ir_text = self.generate_llvm_ir_text(&module, options)?;
        
        // For now, we'll just return the LLVM IR as bytes
        // In a full implementation, we would invoke LLVM to compile to native code
        Ok(llvm_ir_text.as_bytes().to_vec())
    }
    
    fn get_target(&self) -> Target {
        Target::Native
    }
    
    fn supports_optimization(&self) -> bool {
        true
    }
    
    fn get_supported_features(&self) -> Vec<&'static str> {
        vec!["optimization", "debug-info"]
    }
}