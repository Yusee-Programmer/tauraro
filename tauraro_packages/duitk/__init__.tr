# DUITK - Desktop UI Toolkit
# A high-level GUI framework for Tauraro built on native Win32 APIs
# Version: 2.0.0 - Fully native Win32 implementation using FFI

print("Loading DUITK - Desktop UI Toolkit v2.0...")

# Import Win32 API package
import win32

# Load required libraries first
load_library("kernel32.dll")
load_library("user32.dll")

# Define required functions for direct FFI calls
# These need to be defined before calling call_function
define_function("kernel32.dll", "GetModuleHandleA", "pointer", ["pointer"])
define_function("kernel32.dll", "GetLastError", "uint32", [])
define_function("user32.dll", "CreateWindowExA", "pointer", ["uint32", "pointer", "pointer", "uint32", "int32", "int32", "int32", "int32", "pointer", "pointer", "pointer", "pointer"])
define_function("user32.dll", "ShowWindow", "int32", ["pointer", "int32"])
define_function("user32.dll", "UpdateWindow", "int32", ["pointer"])
define_function("user32.dll", "SetForegroundWindow", "int32", ["pointer"])
define_function("user32.dll", "DestroyWindow", "int32", ["pointer"])
define_function("user32.dll", "SetWindowTextA", "int32", ["pointer", "pointer"])
define_function("user32.dll", "MoveWindow", "int32", ["pointer", "int32", "int32", "int32", "int32", "bool"])
define_function("user32.dll", "IsWindow", "int32", ["pointer"])
define_function("kernel32.dll", "Sleep", "void", ["uint32"])
define_function("user32.dll", "MessageBoxA", "int32", ["pointer", "pointer", "pointer", "uint32"])
define_function("user32.dll", "PostQuitMessage", "void", ["int32"])

# Version information
__version__ = "2.0.0"
__name__ = "DUITK"
__description__ = "Desktop UI Toolkit for Tauraro - Native Win32 GUI Framework"

# Helper function to create strings for Win32 APIs
def to_string_ptr(text):
    # Convert Python string to pointer for Win32 APIs
    # In Tauraro, strings are automatically converted when passed to FFI
    return text

# Window class management
_window_classes_registered = {}

def register_window_class(class_name="TauraroWindow"):
    # Register a window class for creating windows
    if class_name in _window_classes_registered:
        return _window_classes_registered[class_name]

    # For simplicity, we'll use the standard "STATIC" class
    # In a full implementation, we would register a custom class with RegisterClassEx
    _window_classes_registered[class_name] = "STATIC"
    return "STATIC"

# Application class
class Application:
    # Main application class that manages windows and message loop

    def __init__(self, name="DUITK Application"):
        self.name = name
        self.windows = []
        self.window_handles = []
        self.running = False
        print("Calling GetModuleHandleA from Application constructor...")
        self.hinstance = call_function("kernel32.dll", "GetModuleHandleA", [0])
        print(f"Application initialized: {name}")
        print(f"  Module handle (HINSTANCE): {self.hinstance}")
        print(f"  hinstance type: {type(self.hinstance)}")
        print(f"  hinstance id: {id(self.hinstance)}")
        if self.hinstance == None:
            print("ERROR: Application hinstance is None!")
            # Try to get last error
            try:
                error = call_function("kernel32.dll", "GetLastError", [])
                print(f"Last error: {error}")
            except Exception as e:
                print(f"Error getting last error: {e}")
        else:
            print(f"Application hinstance set correctly: {self.hinstance}")

    def add_window(self, window):
        # Add a window to the application
        self.windows.append(window)
        return window

    def create_window(self, title, width, height):
        # Create a new window and add it to the application
        print(f"Creating window: {title} ({width}x{height})")

        # CRITICAL: Extract self attributes BEFORE creating Window
        # After accessing window.hwnd, self gets corrupted!
        app_windows = self.windows
        app_handles = self.window_handles
        app_hinstance = self.hinstance

        # StoreFast bug is fixed, we can now directly instantiate!
        window = Window(title, width, height, self, app_hinstance)

        if window != None:
            # Extract hwnd - this will corrupt self!
            try:
                hwnd = window.hwnd

                if hwnd and hwnd != 0:
                    app_windows.append(window)
                    app_handles.append(hwnd)
                    print(f"✓ Window added to application (HWND: {hwnd})")
                else:
                    print(f"✗ ERROR: Window creation failed - invalid HWND")
            except Exception as e:
                print(f"✗ ERROR: Failed to extract window handle: {e}")
        else:
            print(f"✗ ERROR: Window creation failed!")
        return window

    def run(self):
        # Run the message loop until all windows are closed
        self.running = True
        print("Starting message loop...")
        print("Windows will stay open until you close them.")
        print("Close any window to exit the application.\n")

        # Use stored window handles list
        window_handles = self.window_handles

        # Main message loop - runs until all windows are closed
        loop_count = 0
        try:
            while self.running:
                # Check if any windows are still open
                remaining_handles = []
                for hwnd in window_handles:
                    # Check if window still exists
                    try:
                        if call_function("user32.dll", "IsWindow", [hwnd]):
                            remaining_handles.append(hwnd)
                            # Keep window updated and responsive
                            call_function("user32.dll", "UpdateWindow", [hwnd])
                    except:
                        pass

                if len(remaining_handles) == 0:
                    print("\nAll windows closed. Exiting...")
                    break

                window_handles = remaining_handles

                # Small sleep to prevent 100% CPU usage
                # This allows Windows to process messages
                call_function("kernel32.dll", "Sleep", [10])

                loop_count += 1

                # Print status every 500 iterations (approximately every 5 seconds)
                if loop_count % 500 == 0:
                    print(f"Message loop running... ({loop_count} iterations, {len(window_handles)} windows)")

        finally:
            self.running = False

        print(f"Message loop ended after {loop_count} iterations.")
        return loop_count

    def run_simple(self, timeout_seconds=5):
        # Run a simple message loop with timeout (for demos)
        print(f"Running application for {timeout_seconds} seconds...")
        print(f"Windows are now visible on your screen!")
        print(f"You can close them manually, or they will auto-close after {timeout_seconds} seconds...\n")

        # Use stored window handles list
        window_handles = self.window_handles

        # Message loop with timeout
        loop_count = 0
        max_iterations = timeout_seconds * 100

        try:
            while loop_count < max_iterations:
                # Check if any windows are still open
                remaining_handles = []
                for hwnd in window_handles:
                    # Check if window still exists
                    try:
                        if call_function("user32.dll", "IsWindow", [hwnd]):
                            remaining_handles.append(hwnd)
                            # Keep window updated and responsive
                            call_function("user32.dll", "UpdateWindow", [hwnd])
                    except:
                        pass

                if len(remaining_handles) == 0:
                    print("\nAll windows closed by user. Exiting early...")
                    break

                window_handles = remaining_handles

                # Small sleep to prevent 100% CPU usage (10ms sleep = 100 iterations per second)
                call_function("kernel32.dll", "Sleep", [10])
                loop_count += 1

        except:
            pass

        print("Application ended.")

    def quit(self):
        # Quit the application
        self.running = False
        # Post quit message
        try:
            call_function("user32.dll", "PostQuitMessage", [0])
        except:
            pass
        print("Application quit")

# Workaround for Tauraro bug: Factory function for creating Windows
def _create_window_instance(title, width, height, app, hinstance):
    # This is a workaround for Tauraro bug where class instantiation from within
    # another class method returns None
    window = Window()
    window.title = title
    window.width = width
    window.height = height
    window.app = app
    window.controls = []
    window.hwnd = 0
    window.visible = False

    # Initialize the window
    try:
        if hinstance == None:
            print("Getting hinstance using direct FFI...")
            hinstance = call_function("kernel32.dll", "GetModuleHandleA", [0])
            print(f"hinstance from FFI: {hinstance}")
        else:
            print(f"Using provided hinstance: {hinstance}")

        print(f"Creating window: {title} ({width}x{height})")
        print(f"  title type: {type(title)}, value: {title}")
        print(f"  width type: {type(width)}, value: {width}")
        print(f"  height type: {type(height)}, value: {height}")
        print(f"  hinstance type: {type(hinstance)}, value: {hinstance}")

        # Call CreateWindowExA with proper bitwise OR (now works - StoreFast bug fixed!)
        # WS_OVERLAPPEDWINDOW (0x00CF0000) | WS_VISIBLE (0x10000000) = 0x10CF0000 = 282001408
        style = 0x00CF0000 | 0x10000000
        window.hwnd = call_function("user32.dll", "CreateWindowExA", [
            0,
            "BUTTON",
            title,
            style,
            200,
            200,
            width,
            height,
            0,
            0,
            hinstance,
            0
        ])

        print(f"CreateWindowExA returned: {window.hwnd}")

        if window.hwnd and window.hwnd != 0:
            print(f"  ✓ Window created successfully! HWND: {window.hwnd}")
            # Show the window immediately
            call_function("user32.dll", "ShowWindow", [window.hwnd, 5])
            call_function("user32.dll", "UpdateWindow", [window.hwnd])
            call_function("user32.dll", "SetForegroundWindow", [window.hwnd])
            window.visible = True
            print(f"  ✓ Window is now visible on screen!")
        else:
            print(f"  ✗ Failed to create window. HWND: {window.hwnd}")

    except Exception as e:
        print(f"Error creating window: {e}")
        import traceback
        traceback.print_exc()
        window.hwnd = 0

    print(f"Returning window object, hwnd = {window.hwnd}")
    return window

# Window class
class Window:
    # Represents a native Windows window

    def __init__(self, title, width, height, app, hinstance):
        self.title = title
        self.width = width
        self.height = height
        self.app = app
        self.controls = []
        self.hwnd = 0
        self.visible = False

        # Use direct FFI approach which we know works
        try:
            # Get module instance if not provided
            if hinstance == None:
                print("Getting hinstance using direct FFI...")
                hinstance = call_function("kernel32.dll", "GetModuleHandleA", [0])
                print(f"hinstance from FFI: {hinstance}")
            else:
                print(f"Using provided hinstance: {hinstance}")
                
            # Create the window using direct FFI
            print(f"Creating window: {title} ({width}x{height})")
            print(f"  title type: {type(title)}, value: {title}")
            print(f"  width type: {type(width)}, value: {width}")
            print(f"  height type: {type(height)}, value: {height}")
            print(f"  hinstance type: {type(hinstance)}, value: {hinstance}")

            # Call CreateWindowExA with proper bitwise OR (now works - StoreFast bug fixed!)
            # WS_OVERLAPPEDWINDOW (0x00CF0000) | WS_VISIBLE (0x10000000) = 0x10CF0000 = 282001408
            style = 0x00CF0000 | 0x10000000
            self.hwnd = call_function("user32.dll", "CreateWindowExA", [
                0,
                "BUTTON",
                title,
                style,
                200,
                200,
                width,
                height,
                0,
                0,
                hinstance,
                0
            ])
            
            print(f"CreateWindowExA returned: {self.hwnd}")
            
            if self.hwnd and self.hwnd != 0:
                print(f"  ✓ Window created successfully! HWND: {self.hwnd}")
                # Show the window immediately
                call_function("user32.dll", "ShowWindow", [self.hwnd, 5])
                call_function("user32.dll", "UpdateWindow", [self.hwnd])
                call_function("user32.dll", "SetForegroundWindow", [self.hwnd])
                self.visible = True
                print(f"  ✓ Window is now visible on screen!")
            else:
                print(f"  ✗ Failed to create window. HWND: {self.hwnd}")
                
        except Exception as e:
            print(f"Error creating window: {e}")
            import traceback
            traceback.print_exc()
            self.hwnd = 0

        print(f"Exiting Window.__init__, self.hwnd = {self.hwnd}")

    def show(self, cmd=5):
        # Show the window
        if self.hwnd:
            try:
                result = call_function("user32.dll", "ShowWindow", [self.hwnd, cmd])
                call_function("user32.dll", "UpdateWindow", [self.hwnd])
                self.visible = True
                print(f"  Window shown: {self.title}")
                return result
            except Exception as e:
                print(f"  Error showing window: {e}")
        return False

    def hide(self):
        # Hide the window
        if self.hwnd:
            try:
                result = call_function("user32.dll", "ShowWindow", [self.hwnd, 0])
                self.visible = False
                print(f"  Window hidden: {self.title}")
                return result
            except Exception as e:
                print(f"  Error hiding window: {e}")
        return False

    def set_title(self, new_title):
        # Set the window title
        if self.hwnd:
            try:
                call_function("user32.dll", "SetWindowTextA", [self.hwnd, new_title])
                self.title = new_title
                print(f"  Window title changed to: {new_title}")
            except Exception as e:
                print(f"  Error setting title: {e}")
        return self

    def move(self, x, y, w=None, h=None):
        # Move and/or resize the window
        if self.hwnd:
            if w != None:
                width = w
            else:
                width = self.width
            if h != None:
                height = h
            else:
                height = self.height
            try:
                call_function("user32.dll", "MoveWindow", [
                    self.hwnd, x, y, width, height, True
                ])
                self.width = width
                self.height = height
                print(f"  Window moved to ({x}, {y}), size: {width}x{height}")
            except Exception as e:
                print(f"  Error moving window: {e}")
        return self

    def destroy(self):
        # Destroy the window
        if self.hwnd:
            try:
                call_function("user32.dll", "DestroyWindow", [self.hwnd])
                print(f"  Window destroyed: {self.title}")
                self.hwnd = 0
            except Exception as e:
                print(f"  Error destroying window: {e}")

    def create_button(self, text, x, y, width, height):
        # Create a button control
        button = Button(self, text, x, y, width, height)
        self.controls.append(button)
        return button

    def create_label(self, text, x, y, width, height):
        # Create a static label control
        label = Label(self, text, x, y, width, height)
        self.controls.append(label)
        return label

    def create_edit(self, text, x, y, width, height):
        # Create an edit control
        edit = Edit(self, text, x, y, width, height)
        self.controls.append(edit)
        return edit

# Control base class
class Control:
    # Base class for all controls

    def __init__(self, parent, hwnd):
        self.parent = parent
        self.hwnd = hwnd
        self.visible = True

    def show(self):
        # Show the control
        if self.hwnd:
            try:
                call_function("user32.dll", "ShowWindow", [self.hwnd, 5])
                self.visible = True
            except:
                pass
        return self

    def hide(self):
        # Hide the control
        if self.hwnd:
            try:
                call_function("user32.dll", "ShowWindow", [self.hwnd, 0])
                self.visible = False
            except:
                pass
        return self

    def set_text(self, text):
        # Set the control text
        if self.hwnd:
            try:
                call_function("user32.dll", "SetWindowTextA", [self.hwnd, text])
            except:
                pass
        return self

# Button control
class Button(Control):
    # Button control

    def __init__(self, parent, text, x, y, width, height):
        style = 1342177280
        if parent.app != None:
            hinstance = parent.app.hinstance
        else:
            hinstance = call_function("kernel32.dll", "GetModuleHandleA", [0])

        hwnd = 0
        try:
            hwnd = call_function("user32.dll", "CreateWindowExA", [
                0,
                "BUTTON",
                text,
                style,
                x, y, width, height,
                parent.hwnd,
                0,
                hinstance,
                0
            ])

            if hwnd and hwnd != 0:
                print(f"  ✓ Button created: {text}")
            else:
                print(f"  ✗ Failed to create button: {text}")
        except Exception as e:
            print(f"  ✗ Exception creating button: {e}")

        super().__init__(parent, hwnd)
        self.text = text

# Label control (Static text)
class Label(Control):
    # Static label control

    def __init__(self, parent, text, x, y, width, height):
        style = 1342177280
        if parent.app != None:
            hinstance = parent.app.hinstance
        else:
            hinstance = call_function("kernel32.dll", "GetModuleHandleA", [0])

        hwnd = 0
        try:
            hwnd = call_function("user32.dll", "CreateWindowExA", [
                0,
                "STATIC",
                text,
                style,
                x, y, width, height,
                parent.hwnd,
                0,
                hinstance,
                0
            ])

            if hwnd and hwnd != 0:
                print(f"  ✓ Label created: {text}")
            else:
                print(f"  ✗ Failed to create label: {text}")
        except Exception as e:
            print(f"  ✗ Exception creating label: {e}")

        super().__init__(parent, hwnd)
        self.text = text

# Edit control (Text input)
class Edit(Control):
    # Edit control for text input

    def __init__(self, parent, text, x, y, width, height):
        style = 1350565888
        if parent.app != None:
            hinstance = parent.app.hinstance
        else:
            hinstance = call_function("kernel32.dll", "GetModuleHandleA", [0])

        hwnd = 0
        try:
            hwnd = call_function("user32.dll", "CreateWindowExA", [
                0x00000200,
                "EDIT",
                text,
                style,
                x, y, width, height,
                parent.hwnd,
                0,
                hinstance,
                0
            ])

            if hwnd and hwnd != 0:
                print(f"  ✓ Edit control created: {text}")
            else:
                print(f"  ✗ Failed to create edit control: {text}")
        except Exception as e:
            print(f"  ✗ Exception creating edit control: {e}")

        super().__init__(parent, hwnd)
        self.text = text

# Utility functions
def message_box(text, title="Message", type=0):
    # Show a message box
    return call_function("user32.dll", "MessageBoxA", [0, text, title, type])

def get_screen_width():
    # Get the screen width in pixels
    try:
        return call_function("user32.dll", "GetSystemMetrics", [0])
    except:
        return 1920

def get_screen_height():
    # Get the screen height in pixels
    try:
        return call_function("user32.dll", "GetSystemMetrics", [1])
    except:
        return 1080

def create_window(title="Window", width=640, height=480):
    # Quick function to create a standalone window
    return Window(title, width, height)

print("DUITK v2.0 - Desktop UI Toolkit loaded successfully!")
print("  ✓ Native Win32 API integration")
print("  ✓ Full window and control support")
print("  ✓ Message loop handling")
