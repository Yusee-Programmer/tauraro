// Generated by Tauraro Optimized Native C Transpiler
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>

// Tauraro Memory Management Runtime


// Reference counting header for automatic memory management
typedef struct {
    void* ptr;
    size_t refcount;
    size_t size;
    void (*destructor)(void*);
} tauraro_refcounted_t;

// Arena allocator for region-based memory management
typedef struct tauraro_arena {
    char* memory;
    size_t size;
    size_t offset;
    struct tauraro_arena* next;
} tauraro_arena_t;


// Manual Memory Management Functions

// Manual allocation (user must call free)
static inline void* tauraro_alloc(size_t size) {
    void* ptr = malloc(size);
    if (!ptr) {
        fprintf(stderr, "Tauraro: Memory allocation failed\n");
        exit(1);
    }
    return ptr;
}

// Manual deallocation
static inline void tauraro_free(void* ptr) {
    if (ptr) {
        free(ptr);
    }
}

// Reallocate memory
static inline void* tauraro_realloc(void* ptr, size_t new_size) {
    void* new_ptr = realloc(ptr, new_size);
    if (!new_ptr && new_size > 0) {
        fprintf(stderr, "Tauraro: Memory reallocation failed\n");
        exit(1);
    }
    return new_ptr;
}


// Native built-in function implementations


// int() - Convert to integer
int64_t tauraro_int_from_float(double x) {
    return (int64_t)x;
}

int64_t tauraro_int_from_str(const char* s) {
    return (int64_t)atoll(s);
}

int64_t tauraro_int_from_bool(bool b) {
    return b ? 1 : 0;
}

// float() - Convert to float
double tauraro_float_from_int(int64_t x) {
    return (double)x;
}

double tauraro_float_from_str(const char* s) {
    return atof(s);
}

double tauraro_float_from_bool(bool b) {
    return b ? 1.0 : 0.0;
}

// str() - Convert to string
char* tauraro_str_from_int(int64_t x) {
    char* buf = malloc(32);
    snprintf(buf, 32, "%lld", x);
    return buf;
}

char* tauraro_str_from_float(double x) {
    char* buf = malloc(32);
    snprintf(buf, 32, "%g", x);
    return buf;
}

char* tauraro_str_from_bool(bool b) {
    return strdup(b ? "True" : "False");
}

char* tauraro_str_copy(const char* s) {
    return strdup(s);
}

// bool() - Convert to boolean
bool tauraro_bool_from_int(int64_t x) {
    return x != 0;
}

bool tauraro_bool_from_float(double x) {
    return x != 0.0;
}

bool tauraro_bool_from_str(const char* s) {
    return s != NULL && s[0] != '\0';
}

// len() - Get length of string or container
int64_t tauraro_len_str(const char* s) {
    return s ? (int64_t)strlen(s) : 0;
}

int64_t tauraro_len_list(tauraro_native_list_t* list) {
    return list ? (int64_t)list->size : 0;
}

int64_t tauraro_len_dict(tauraro_native_dict_t* dict) {
    return dict ? (int64_t)dict->size : 0;
}

// min() - Find minimum value
int64_t tauraro_min_int(int64_t a, int64_t b) {
    return a < b ? a : b;
}

double tauraro_min_float(double a, double b) {
    return a < b ? a : b;
}

int64_t tauraro_min_int_array(int64_t* arr, size_t len) {
    if (len == 0) return 0;
    int64_t min_val = arr[0];
    for (size_t i = 1; i < len; i++) {
        if (arr[i] < min_val) min_val = arr[i];
    }
    return min_val;
}

// max() - Find maximum value
int64_t tauraro_max_int(int64_t a, int64_t b) {
    return a > b ? a : b;
}

double tauraro_max_float(double a, double b) {
    return a > b ? a : b;
}

int64_t tauraro_max_int_array(int64_t* arr, size_t len) {
    if (len == 0) return 0;
    int64_t max_val = arr[0];
    for (size_t i = 1; i < len; i++) {
        if (arr[i] > max_val) max_val = arr[i];
    }
    return max_val;
}

// sum() - Sum elements
int64_t tauraro_sum_int_array(int64_t* arr, size_t len) {
    int64_t total = 0;
    for (size_t i = 0; i < len; i++) {
        total += arr[i];
    }
    return total;
}

double tauraro_sum_float_array(double* arr, size_t len) {
    double total = 0.0;
    for (size_t i = 0; i < len; i++) {
        total += arr[i];
    }
    return total;
}

// abs() - Absolute value
int64_t tauraro_abs_int(int64_t x) {
    return x < 0 ? -x : x;
}

double tauraro_abs_float(double x) {
    return fabs(x);
}

// pow() - Power operation
double tauraro_pow_native(double base, double exp) {
    return pow(base, exp);
}

int64_t tauraro_pow_int(int64_t base, int64_t exp) {
    if (exp == 0) return 1;
    if (exp < 0) return 0; // Integer division

    int64_t result = 1;
    int64_t b = base;
    int64_t e = exp;

    while (e > 0) {
        if (e & 1) result *= b;
        b *= b;
        e >>= 1;
    }
    return result;
}

// round() - Round to nearest integer
int64_t tauraro_round_to_int(double x) {
    return (int64_t)round(x);
}

double tauraro_round_to_places(double x, int places) {
    double multiplier = pow(10.0, places);
    return round(x * multiplier) / multiplier;
}

// input() - Read line from stdin
char* tauraro_input(const char* prompt) {
    if (prompt) {
        printf("%s", prompt);
        fflush(stdout);
    }

    char* line = NULL;
    size_t len = 0;
    ssize_t read = getline(&line, &len, stdin);

    if (read != -1) {
        // Remove trailing newline
        if (line[read - 1] == '\n') {
            line[read - 1] = '\0';
        }
        return line;
    }

    return strdup("");
}

// isinstance() - Type checking
bool tauraro_isinstance_int(int64_t x) {
    return true; // If it's an int64_t, it's an int
}

bool tauraro_isinstance_float(double x) {
    return true;
}

bool tauraro_isinstance_str(const char* x) {
    return x != NULL;
}

// Native type system for high-performance compilation
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>


// Native dynamic list (similar to C++ vector)
typedef struct tauraro_native_list {
    void** items;
    size_t size;
    size_t capacity;
    size_t item_size; // Size of each element
} tauraro_native_list_t;

tauraro_native_list_t* tauraro_native_list_new(size_t item_size) {
    tauraro_native_list_t* list = malloc(sizeof(tauraro_native_list_t));
    list->capacity = 8;
    list->size = 0;
    list->item_size = item_size;
    list->items = malloc(list->capacity * sizeof(void*));
    return list;
}

void tauraro_native_list_append(tauraro_native_list_t* list, void* item) {
    if (list->size >= list->capacity) {
        list->capacity *= 2;
        list->items = realloc(list->items, list->capacity * sizeof(void*));
    }
    list->items[list->size++] = item;
}

void* tauraro_native_list_get(tauraro_native_list_t* list, int64_t index) {
    if (index < 0) index += list->size;
    if (index >= 0 && (size_t)index < list->size) {
        return list->items[index];
    }
    return NULL;
}

void tauraro_native_list_set(tauraro_native_list_t* list, int64_t index, void* item) {
    if (index < 0) index += list->size;
    if (index >= 0 && (size_t)index < list->size) {
        list->items[index] = item;
    }
}

void tauraro_native_list_free(tauraro_native_list_t* list) {
    if (list) {
        free(list->items);
        free(list);
    }
}

// Native dictionary (hash table)
typedef struct tauraro_dict_entry {
    char* key;
    void* value;
    struct tauraro_dict_entry* next;
} tauraro_dict_entry_t;

typedef struct tauraro_native_dict {
    tauraro_dict_entry_t** buckets;
    size_t capacity;
    size_t size;
} tauraro_native_dict_t;

static unsigned long tauraro_hash_string(const char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash;
}

tauraro_native_dict_t* tauraro_native_dict_new() {
    tauraro_native_dict_t* dict = malloc(sizeof(tauraro_native_dict_t));
    dict->capacity = 16;
    dict->size = 0;
    dict->buckets = calloc(dict->capacity, sizeof(tauraro_dict_entry_t*));
    return dict;
}

void tauraro_native_dict_set(tauraro_native_dict_t* dict, const char* key, void* value) {
    unsigned long hash = tauraro_hash_string(key);
    size_t index = hash % dict->capacity;

    // Check if key exists
    tauraro_dict_entry_t* entry = dict->buckets[index];
    while (entry) {
        if (strcmp(entry->key, key) == 0) {
            entry->value = value;
            return;
        }
        entry = entry->next;
    }

    // Add new entry
    tauraro_dict_entry_t* new_entry = malloc(sizeof(tauraro_dict_entry_t));
    new_entry->key = strdup(key);
    new_entry->value = value;
    new_entry->next = dict->buckets[index];
    dict->buckets[index] = new_entry;
    dict->size++;
}

void* tauraro_native_dict_get(tauraro_native_dict_t* dict, const char* key) {
    unsigned long hash = tauraro_hash_string(key);
    size_t index = hash % dict->capacity;

    tauraro_dict_entry_t* entry = dict->buckets[index];
    while (entry) {
        if (strcmp(entry->key, key) == 0) {
            return entry->value;
        }
        entry = entry->next;
    }
    return NULL;
}

void tauraro_native_dict_free(tauraro_native_dict_t* dict) {
    if (dict) {
        for (size_t i = 0; i < dict->capacity; i++) {
            tauraro_dict_entry_t* entry = dict->buckets[i];
            while (entry) {
                tauraro_dict_entry_t* next = entry->next;
                free(entry->key);
                free(entry);
                entry = next;
            }
        }
        free(dict->buckets);
        free(dict);
    }
}

// Forward declarations
// Function: calculate_sum
// Function: calculate_factorial
// Function: sum_of_squares
// Function: fibonacci
// Function: is_prime

int64_t calculate_sum(int64_t n) {
    int64_t total = 0;
    for (int64_t i = 0; i < n; i += 1) {
        int64_t total = (total + i);
    }
    return total;
}

int64_t calculate_factorial(int64_t n) {
    if ((n <= 1)) {
        return 1;
    }
    int64_t result = 1;
    for (int64_t i = 2; i < (n + 1); i += 1) {
        int64_t result = (result * i);
    }
    return result;
}

double sum_of_squares(int64_t n) {
    double total = 0;
    for (int64_t i = 0; i < n; i += 1) {
        double x = tauraro_float_from_int(i);
        double square = (x * x);
        double total = (total + square);
    }
    return total;
}

int64_t fibonacci(int64_t n) {
    if ((n <= 1)) {
        return n;
    }
    int64_t a = 0;
    int64_t b = 1;
    for (int64_t i = 2; i < (n + 1); i += 1) {
        int64_t temp = (a + b);
        int64_t a = b;
        int64_t b = temp;
    }
    return b;
}

bool is_prime(int64_t n) {
    if ((n <= 1)) {
        return false;
    }
    if ((n == 2)) {
        return true;
    }
    if (((n % 2) == 0)) {
        return false;
    }
    int64_t i = 3;
    while (((i * i) <= n)) {
        if (((n % i) == 0)) {
            return false;
        }
        int64_t i = (i + 2);
    }
    return true;
}

int main(int argc, char** argv) {
    /* unsupported statement */;
    /* unsupported statement */;
    printf("%s\n", "=== Native Memory Management Test ===");
    /* unsupported statement */;
    printf("%s\n", "
1. Basic calculations:");
    int64_t sum_result = calculate_sum(100);
    printf("%p\n", /* unsupported expr */);
    int64_t fact_result = calculate_factorial(10);
    printf("%p\n", /* unsupported expr */);
    double squares_result = sum_of_squares(50);
    printf("%p\n", /* unsupported expr */);
    printf("%s\n", "
2. Fibonacci numbers:");
    /* generic for loop not yet implemented */
    printf("%s\n", "
3. Testing prime check:");
    printf("%p\n", /* unsupported expr */);
    printf("%p\n", /* unsupported expr */);
    printf("%p\n", /* unsupported expr */);
    printf("%p\n", /* unsupported expr */);
    printf("%p\n", /* unsupported expr */);
    printf("%s\n", "
4. Performance test - large calculations:");
    int64_t large_sum = calculate_sum(10000);
    printf("%p\n", /* unsupported expr */);
    double large_squares = sum_of_squares(1000);
    printf("%p\n", /* unsupported expr */);
    printf("%s\n", "
=== All Tests Completed ===");
    return 0;
}
