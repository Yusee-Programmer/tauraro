# Advanced Functools Module Test
import functools

print("=== Advanced Functools Module Test ===")

# Test partial with different argument combinations
print("\n--- Partial Tests ---")
def multiply(x, y, z):
    return x * y * z

# Create partial functions with different fixed arguments
double = functools.partial(multiply, 2)
triple = functools.partial(multiply, y=3)
specific = functools.partial(multiply, 2, 3, 4)

print("Double(3, 4):", double(3, 4))
print("Triple(x=2, z=4):", triple(x=2, z=4))
print("Specific():", specific())

# Test reduce with different functions
print("\n--- Reduce Tests ---")
numbers = [1, 2, 3, 4, 5]
sum_result = functools.reduce(lambda x, y: x + y, numbers)
product_result = functools.reduce(lambda x, y: x * y, numbers)
max_result = functools.reduce(lambda x, y: x if x > y else y, numbers)

print("Sum:", sum_result)
print("Product:", product_result)
print("Max:", max_result)

# Test reduce with initializer
sum_with_init = functools.reduce(lambda x, y: x + y, numbers, 10)
print("Sum with initializer (10):", sum_with_init)

# Test lru_cache
print("\n--- LRU Cache Tests ---")
@functools.lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print("Fibonacci(10):", fibonacci(10))
print("Cache info:", fibonacci.cache_info())

# Test cache clear
fibonacci.cache_clear()
print("After cache clear:", fibonacci.cache_info())

# Test cache decorator
@functools.cache
def factorial(n):
    return 1 if n < 2 else n * factorial(n-1)

print("\nFactorial(5):", factorial(5))
print("Cache info:", factorial.cache_info())

# Test wraps decorator
print("\n--- Wraps Tests ---")
def my_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Finished {func.__name__}")
        return result
    return wrapper

@my_decorator
def greet(name):
    """Greet someone"""
    return f"Hello, {name}!"

print("Greeting:", greet("Tauraro"))
print("Function name:", greet.__name__)
print("Function doc:", greet.__doc__)

# Test total_ordering
print("\n--- Total Ordering Tests ---")
@functools.total_ordering
class Student:
    def __init__(self, name, grade):
        self.name = name
        self.grade = grade
    
    def __eq__(self, other):
        return self.grade == other.grade
    
    def __lt__(self, other):
        return self.grade < other.grade
    
    def __repr__(self):
        return f"Student('{self.name}', {self.grade})"

s1 = Student("Alice", 85)
s2 = Student("Bob", 90)
s3 = Student("Charlie", 85)

print("Students:", s1, s2, s3)
print("s1 < s2:", s1 < s2)
print("s1 > s2:", s1 > s2)
print("s1 <= s3:", s1 <= s3)
print("s1 >= s3:", s1 >= s3)
print("s1 == s3:", s1 == s3)

# Test cmp_to_key
print("\n--- Cmp To Key Tests ---")
def compare(a, b):
    return (a > b) - (a < b)

numbers = [5, 2, 4, 1, 3]
sorted_numbers = sorted(numbers, key=functools.cmp_to_key(compare))
print("Original:", numbers)
print("Sorted:", sorted_numbers)

print("Advanced Functools module test completed successfully!")