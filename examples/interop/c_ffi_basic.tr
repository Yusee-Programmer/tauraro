#!/usr/bin/env tauraro
"""
Example: Basic C FFI

This example demonstrates how to use TauraroLang's Foreign Function
Interface (FFI) to call C functions from external libraries.

Features demonstrated:
- Loading external C libraries
- Declaring external functions
- Type conversion between TauraroLang and C
- Memory management with C functions
- Error handling in FFI calls

Usage:
    # Compile TauraroLang with FFI support
    cargo build --features ffi
    
    # Run the example
    tauraro run examples/interop/c_ffi_basic.tr
    
Requirements:
    - TauraroLang with FFI feature enabled
    - Standard C library (available on most systems)
"""

fn main() {
    print("=== C FFI Basic Demo ===")
    
    // Load the standard C library
    // On Windows: msvcrt.dll, on Linux: libc.so.6, on macOS: libc.dylib
    let libc = load_library("libc")
    
    if libc == null {
        print("Failed to load C library")
        return
    }
    
    print("Successfully loaded C library")
    
    // Declare external C functions
    print("\n--- String Functions ---")
    
    // strlen - get string length
    register_function(libc, "strlen", "int", ["string"])
    let test_string = "Hello, World!"
    let length = call_function(libc, "strlen", [test_string])
    print("Length of '" + test_string + "': " + str(length))
    
    // strcmp - compare strings
    register_function(libc, "strcmp", "int", ["string", "string"])
    let str1 = "apple"
    let str2 = "banana"
    let str3 = "apple"
    
    let cmp1 = call_function(libc, "strcmp", [str1, str2])
    let cmp2 = call_function(libc, "strcmp", [str1, str3])
    
    print("strcmp('" + str1 + "', '" + str2 + "'): " + str(cmp1))
    print("strcmp('" + str1 + "', '" + str3 + "'): " + str(cmp2))
    
    // Memory management functions
    print("\n--- Memory Management ---")
    
    // malloc - allocate memory
    register_function(libc, "malloc", "pointer", ["int"])
    let size = 1024
    let ptr = call_function(libc, "malloc", [size])
    
    if ptr != null {
        print("Allocated " + str(size) + " bytes at address: " + str(ptr))
        
        // free - deallocate memory
        register_function(libc, "free", "void", ["pointer"])
        call_function(libc, "free", [ptr])
        print("Memory freed successfully")
    } else {
        print("Failed to allocate memory")
    }
    
    // Mathematical functions
    print("\n--- Math Functions ---")
    
    // Load math library (may be separate on some systems)
    let libm = load_library("libm")
    if libm != null {
        // sqrt - square root
        register_function(libm, "sqrt", "float", ["float"])
        let number = 16.0
        let sqrt_result = call_function(libm, "sqrt", [number])
        print("sqrt(" + str(number) + ") = " + str(sqrt_result))
        
        // pow - power function
        register_function(libm, "pow", "float", ["float", "float"])
        let base = 2.0
        let exponent = 8.0
        let pow_result = call_function(libm, "pow", [base, exponent])
        print("pow(" + str(base) + ", " + str(exponent) + ") = " + str(pow_result))
    } else {
        print("Math library not available or integrated into libc")
    }
    
    // Working with buffers
    print("\n--- Buffer Operations ---")
    
    // Create a buffer and work with it
    let buffer_size = 256
    let buffer = call_function(libc, "malloc", [buffer_size])
    
    if buffer != null {
        print("Created buffer of " + str(buffer_size) + " bytes")
        
        // memset - fill memory with a value
        register_function(libc, "memset", "pointer", ["pointer", "int", "int"])
        call_function(libc, "memset", [buffer, 0, buffer_size])
        print("Buffer initialized with zeros")
        
        // Clean up
        call_function(libc, "free", [buffer])
        print("Buffer freed")
    }
    
    // Error handling example
    print("\n--- Error Handling ---")
    
    try {
        // Attempt to call a non-existent function
        register_function(libc, "nonexistent_function", "int", [])
        let result = call_function(libc, "nonexistent_function", [])
        print("This shouldn't print")
    } catch error {
        print("Caught FFI error: " + str(error))
    }
    
    // Safe FFI context example
    print("\n--- Safe FFI Context ---")
    
    with_safe_ffi(fn() {
        let safe_ptr = call_function(libc, "malloc", [512])
        if safe_ptr != null {
            print("Allocated memory safely: " + str(safe_ptr))
            // Memory will be automatically freed when context exits
        }
    })
    
    print("Safe FFI context completed - memory automatically cleaned up")
    
    // Type conversion examples
    print("\n--- Type Conversions ---")
    
    // Integer conversions
    let tauraro_int = 42
    let c_int = to_c_int(tauraro_int)
    print("TauraroLang int " + str(tauraro_int) + " -> C int: " + str(c_int))
    
    // Float conversions
    let tauraro_float = 3.14159
    let c_float = to_c_float(tauraro_float)
    print("TauraroLang float " + str(tauraro_float) + " -> C float: " + str(c_float))
    
    // String conversions
    let tauraro_string = "Hello, C!"
    let c_string = to_c_string(tauraro_string)
    print("TauraroLang string '" + tauraro_string + "' -> C string: " + str(c_string))
    
    print("\n=== FFI Demo Complete ===")
}