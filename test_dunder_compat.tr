# Test 1: Object Base Class (WORKING)
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        return "Some sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

dog = Dog("Buddy")
print(f"Dog name: {dog.name}")
print(f"Dog speaks: {dog.speak()}")

# Test if Dog inherits from object
print(f"Dog bases should include object: {Dog.__bases__ if hasattr(Dog, '__bases__') else 'No __bases__ attr'}")

# Test 2: Custom Dunder Methods (WORKING)
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return Vector(self.x + other, self.y + other)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2
print(f"\nVector test: {v1} + {v2} = Vector({v3.x}, {v3.y})")

# Test 3: What's MISSING - Built-in type dunders
print("\n=== Testing Built-in Type Dunders ===")

# Currently len() works via internal logic
my_list = [1, 2, 3]
print(f"len([1,2,3]) = {len(my_list)}")

# But trying to call __len__() directly won't work
try:
    result = my_list.__len__()
    print(f"[1,2,3].__len__() = {result}")
except:
    print("ERROR: list.__len__() not available as dunder method")

# Similarly, subscript access works
print(f"[1,2,3][0] = {my_list[0]}")
# But __getitem__() is not exposed
try:
    result = my_list.__getitem__(0)
    print(f"[1,2,3].__getitem__(0) = {result}")
except:
    print("ERROR: list.__getitem__() not available as dunder method")

# Test 4: type() limitations (PARTIAL)
print("\n=== Testing type() ===")

# 1-argument form works (returns type name as string)
print(f"type(42) = {type(42)}")
print(f"type([1,2,3]) = {type([1,2,3])}")

# 3-argument form (dynamic class creation) doesn't work yet
try:
    def my_method(self):
        return "Hello from dynamic class"
    
    DynamicClass = type('DynamicClass', (object,), {'method': my_method})
    obj = DynamicClass()
    print(f"Dynamic class created: {obj.method()}")
except Exception as e:
    print(f"ERROR: type(name, bases, dict) not supported yet: {e}")

# Test 5: What we need for 100% compatibility
print("\n=== Missing Features for Full Python Compatibility ===")
print("1. Built-in type dunders:")
print("   - __len__(), __getitem__(), __setitem__(), __delitem__()")
print("   - __contains__() for 'in' operator")
print("   - __iter__(), __next__() for iteration")
print("   - __hash__() for hashable types")
print("2. Metaclasses:")
print("   - type(name, bases, dict) for dynamic class creation")
print("   - Custom metaclass support via metaclass= parameter")
print("3. Attribute access dunders:")
print("   - __getattr__(), __setattr__(), __delattr__()")
print("4. Other dunders:")
print("   - __bool__() for truthiness")
print("   - __call__() for callable objects")
print("   - Bitwise: __and__(), __or__(), __xor__(), __lshift__(), __rshift__()")
print("   - Unary: __neg__(), __pos__(), __abs__(), __invert__()")
print("   - Floor/Mod: __floordiv__(), __mod__()")
