// Generated by Tauraro Optimized Native C Transpiler
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>

// Tauraro Memory Management Runtime


// Reference counting header for automatic memory management
typedef struct {
    void* ptr;
    size_t refcount;
    size_t size;
    void (*destructor)(void*);
} tauraro_refcounted_t;

// Arena allocator for region-based memory management
typedef struct tauraro_arena {
    char* memory;
    size_t size;
    size_t offset;
    struct tauraro_arena* next;
} tauraro_arena_t;

// Forward declarations for native container types
typedef struct tauraro_native_list tauraro_native_list_t;
typedef struct tauraro_native_dict tauraro_native_dict_t;
typedef struct tauraro_dict_entry tauraro_dict_entry_t;


// Automatic Memory Management Functions

// Create a reference-counted object
static inline tauraro_refcounted_t* tauraro_alloc_rc(size_t size, void (*destructor)(void*)) {
    tauraro_refcounted_t* rc = (tauraro_refcounted_t*)malloc(sizeof(tauraro_refcounted_t));
    rc->ptr = malloc(size);
    rc->refcount = 1;
    rc->size = size;
    rc->destructor = destructor;
    return rc;
}

// Increment reference count
static inline void tauraro_incref(tauraro_refcounted_t* rc) {
    if (rc) {
        rc->refcount++;
    }
}

// Decrement reference count and free if zero
static inline void tauraro_decref(tauraro_refcounted_t* rc) {
    if (rc && --rc->refcount == 0) {
        if (rc->destructor) {
            rc->destructor(rc->ptr);
        }
        free(rc->ptr);
        free(rc);
    }
}

// Get pointer from reference-counted object
static inline void* tauraro_rc_ptr(tauraro_refcounted_t* rc) {
    return rc ? rc->ptr : NULL;
}

// String destructor for automatic mode
static inline void tauraro_str_destructor(void* ptr) {
    // Strings allocated with strdup/malloc
    free(ptr);
}

// Array destructor for automatic mode
static inline void tauraro_array_destructor(void* ptr) {
    // Simple free for arrays
    free(ptr);
}


// Native type system for high-performance compilation
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>


// Native dynamic list (similar to C++ vector)
typedef struct tauraro_native_list {
    void** items;
    size_t size;
    size_t capacity;
    size_t item_size; // Size of each element
} tauraro_native_list_t;

tauraro_native_list_t* tauraro_native_list_new(size_t item_size) {
    tauraro_native_list_t* list = malloc(sizeof(tauraro_native_list_t));
    list->capacity = 8;
    list->size = 0;
    list->item_size = item_size;
    list->items = malloc(list->capacity * sizeof(void*));
    return list;
}

void tauraro_native_list_append(tauraro_native_list_t* list, void* item) {
    if (list->size >= list->capacity) {
        list->capacity *= 2;
        list->items = realloc(list->items, list->capacity * sizeof(void*));
    }
    list->items[list->size++] = item;
}

void* tauraro_native_list_get(tauraro_native_list_t* list, int64_t index) {
    if (index < 0) index += list->size;
    if (index >= 0 && (size_t)index < list->size) {
        return list->items[index];
    }
    return NULL;
}

void tauraro_native_list_set(tauraro_native_list_t* list, int64_t index, void* item) {
    if (index < 0) index += list->size;
    if (index >= 0 && (size_t)index < list->size) {
        list->items[index] = item;
    }
}

void tauraro_native_list_free(tauraro_native_list_t* list) {
    if (list) {
        free(list->items);
        free(list);
    }
}

// Native dictionary (hash table)
typedef struct tauraro_dict_entry {
    char* key;
    void* value;
    struct tauraro_dict_entry* next;
} tauraro_dict_entry_t;

typedef struct tauraro_native_dict {
    tauraro_dict_entry_t** buckets;
    size_t capacity;
    size_t size;
} tauraro_native_dict_t;

static unsigned long tauraro_hash_string(const char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash;
}

tauraro_native_dict_t* tauraro_native_dict_new() {
    tauraro_native_dict_t* dict = malloc(sizeof(tauraro_native_dict_t));
    dict->capacity = 16;
    dict->size = 0;
    dict->buckets = calloc(dict->capacity, sizeof(tauraro_dict_entry_t*));
    return dict;
}

void tauraro_native_dict_set(tauraro_native_dict_t* dict, const char* key, void* value) {
    unsigned long hash = tauraro_hash_string(key);
    size_t index = hash % dict->capacity;

    // Check if key exists
    tauraro_dict_entry_t* entry = dict->buckets[index];
    while (entry) {
        if (strcmp(entry->key, key) == 0) {
            entry->value = value;
            return;
        }
        entry = entry->next;
    }

    // Add new entry
    tauraro_dict_entry_t* new_entry = malloc(sizeof(tauraro_dict_entry_t));
    new_entry->key = strdup(key);
    new_entry->value = value;
    new_entry->next = dict->buckets[index];
    dict->buckets[index] = new_entry;
    dict->size++;
}

void* tauraro_native_dict_get(tauraro_native_dict_t* dict, const char* key) {
    unsigned long hash = tauraro_hash_string(key);
    size_t index = hash % dict->capacity;

    tauraro_dict_entry_t* entry = dict->buckets[index];
    while (entry) {
        if (strcmp(entry->key, key) == 0) {
            return entry->value;
        }
        entry = entry->next;
    }
    return NULL;
}

void tauraro_native_dict_free(tauraro_native_dict_t* dict) {
    if (dict) {
        for (size_t i = 0; i < dict->capacity; i++) {
            tauraro_dict_entry_t* entry = dict->buckets[i];
            while (entry) {
                tauraro_dict_entry_t* next = entry->next;
                free(entry->key);
                free(entry);
                entry = next;
            }
        }
        free(dict->buckets);
        free(dict);
    }
}

// Native built-in function implementations


// int() - Convert to integer
int64_t tauraro_int_from_float(double x) {
    return (int64_t)x;
}

int64_t tauraro_int_from_str(const char* s) {
    return (int64_t)atoll(s);
}

int64_t tauraro_int_from_bool(bool b) {
    return b ? 1 : 0;
}

// float() - Convert to float
double tauraro_float_from_int(int64_t x) {
    return (double)x;
}

double tauraro_float_from_str(const char* s) {
    return atof(s);
}

double tauraro_float_from_bool(bool b) {
    return b ? 1.0 : 0.0;
}

// str() - Convert to string
char* tauraro_str_from_int(int64_t x) {
    char* buf = malloc(32);
    snprintf(buf, 32, "%lld", x);
    return buf;
}

char* tauraro_str_from_float(double x) {
    char* buf = malloc(32);
    snprintf(buf, 32, "%g", x);
    return buf;
}

char* tauraro_str_from_bool(bool b) {
    return strdup(b ? "True" : "False");
}

char* tauraro_str_copy(const char* s) {
    return strdup(s);
}

// bool() - Convert to boolean
bool tauraro_bool_from_int(int64_t x) {
    return x != 0;
}

bool tauraro_bool_from_float(double x) {
    return x != 0.0;
}

bool tauraro_bool_from_str(const char* s) {
    return s != NULL && s[0] != '\0';
}

// len() - Get length of string or container
int64_t tauraro_len_str(const char* s) {
    return s ? (int64_t)strlen(s) : 0;
}

int64_t tauraro_len_list(tauraro_native_list_t* list) {
    return list ? (int64_t)list->size : 0;
}

int64_t tauraro_len_dict(tauraro_native_dict_t* dict) {
    return dict ? (int64_t)dict->size : 0;
}

// min() - Find minimum value
int64_t tauraro_min_int(int64_t a, int64_t b) {
    return a < b ? a : b;
}

double tauraro_min_float(double a, double b) {
    return a < b ? a : b;
}

int64_t tauraro_min_int_array(int64_t* arr, size_t len) {
    if (len == 0) return 0;
    int64_t min_val = arr[0];
    for (size_t i = 1; i < len; i++) {
        if (arr[i] < min_val) min_val = arr[i];
    }
    return min_val;
}

// max() - Find maximum value
int64_t tauraro_max_int(int64_t a, int64_t b) {
    return a > b ? a : b;
}

double tauraro_max_float(double a, double b) {
    return a > b ? a : b;
}

int64_t tauraro_max_int_array(int64_t* arr, size_t len) {
    if (len == 0) return 0;
    int64_t max_val = arr[0];
    for (size_t i = 1; i < len; i++) {
        if (arr[i] > max_val) max_val = arr[i];
    }
    return max_val;
}

// sum() - Sum elements
int64_t tauraro_sum_int_array(int64_t* arr, size_t len) {
    int64_t total = 0;
    for (size_t i = 0; i < len; i++) {
        total += arr[i];
    }
    return total;
}

double tauraro_sum_float_array(double* arr, size_t len) {
    double total = 0.0;
    for (size_t i = 0; i < len; i++) {
        total += arr[i];
    }
    return total;
}

// abs() - Absolute value
int64_t tauraro_abs_int(int64_t x) {
    return x < 0 ? -x : x;
}

double tauraro_abs_float(double x) {
    return fabs(x);
}

// pow() - Power operation
double tauraro_pow_native(double base, double exp) {
    return pow(base, exp);
}

int64_t tauraro_pow_int(int64_t base, int64_t exp) {
    if (exp == 0) return 1;
    if (exp < 0) return 0; // Integer division

    int64_t result = 1;
    int64_t b = base;
    int64_t e = exp;

    while (e > 0) {
        if (e & 1) result *= b;
        b *= b;
        e >>= 1;
    }
    return result;
}

// round() - Round to nearest integer
int64_t tauraro_round_to_int(double x) {
    return (int64_t)round(x);
}

double tauraro_round_to_places(double x, int places) {
    double multiplier = pow(10.0, places);
    return round(x * multiplier) / multiplier;
}

// input() - Read line from stdin (cross-platform)
char* tauraro_input(const char* prompt) {
    if (prompt) {
        printf("%s", prompt);
        fflush(stdout);
    }

    // Cross-platform implementation using fgets
    size_t buffer_size = 256;
    char* line = (char*)malloc(buffer_size);
    if (!line) return strdup("");

    size_t pos = 0;
    int c;

    while ((c = fgetc(stdin)) != EOF && c != '\n') {
        // Grow buffer if needed
        if (pos >= buffer_size - 1) {
            buffer_size *= 2;
            char* new_line = (char*)realloc(line, buffer_size);
            if (!new_line) {
                free(line);
                return strdup("");
            }
            line = new_line;
        }
        line[pos++] = (char)c;
    }

    line[pos] = '\0';
    return line;
}

// isinstance() - Type checking
bool tauraro_isinstance_int(int64_t x) {
    return true; // If it's an int64_t, it's an int
}

bool tauraro_isinstance_float(double x) {
    return true;
}

bool tauraro_isinstance_str(const char* x) {
    return x != NULL;
}

// Forward declarations

int main(int argc, char** argv) {
    /* unsupported statement */;
    /* unsupported expr */;
    /* unsupported statement */;
    /* unsupported statement */;
    printf("%s\n", "Testing math module:");
    printf("%p\n", /* f-string: sqrt(16) = %p with args: ["/* unsupported expr */"] */);
    printf("%p\n", /* f-string: pow(2, 3) = %p with args: ["/* unsupported expr */"] */);
    printf("%p\n", /* f-string: sin(0) = %p with args: ["/* unsupported expr */"] */);
    printf("%p\n", /* f-string: cos(0) = %p with args: ["/* unsupported expr */"] */);
    printf("%p\n", /* f-string: pi = %p with args: ["math.pi"] */);
    printf("%p\n", /* f-string: e = %p with args: ["math.e"] */);
    printf("%s\n", "\nMath module test completed successfully!");
    return 0;
}
